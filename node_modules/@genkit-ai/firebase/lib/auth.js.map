{"version":3,"sources":["../src/auth.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { __RequestWithAuth } from '@genkit-ai/flow';\nimport { Response } from 'express';\nimport { DecodedIdToken, getAuth } from 'firebase-admin/auth';\nimport * as z from 'zod';\nimport { FunctionFlowAuth } from './functions.js';\nimport { initializeAppIfNecessary } from './helpers.js';\n\nexport function firebaseAuth<I extends z.ZodTypeAny>(\n  policy: (user: DecodedIdToken, input: z.infer<I>) => void | Promise<void>\n): FunctionFlowAuth<I>;\nexport function firebaseAuth<I extends z.ZodTypeAny>(\n  policy: (user: DecodedIdToken, input: z.infer<I>) => void | Promise<void>,\n  config: { required: true }\n): FunctionFlowAuth<I>;\nexport function firebaseAuth<I extends z.ZodTypeAny>(\n  policy: (\n    user: DecodedIdToken | undefined,\n    input: z.infer<I>\n  ) => void | Promise<void>,\n  config: { required: false }\n): FunctionFlowAuth<I>;\nexport function firebaseAuth<I extends z.ZodTypeAny>(\n  policy: (user: DecodedIdToken, input: z.infer<I>) => void | Promise<void>,\n  config?: { required: boolean }\n): FunctionFlowAuth<I> {\n  initializeAppIfNecessary();\n  const required = config?.required || true;\n  return {\n    async policy(auth: unknown | undefined, input: z.infer<I>) {\n      // If required is true, then auth will always be set when called from\n      // an HTTP context. However, we need to wrap the user-provided policy\n      // to check for presence of auth when the flow is executed from runFlow\n      // or an action context.\n      if (required && !auth) {\n        throw new Error('Auth is required');\n      }\n\n      return policy(auth as DecodedIdToken, input);\n    },\n    async provider(req, res, next) {\n      const token = req.headers['authorization']?.split(/[Bb]earer /)[1];\n      let decoded: DecodedIdToken;\n\n      if (!token) {\n        if (required) {\n          unauthorized(res);\n        } else {\n          next();\n        }\n        return;\n      }\n      try {\n        decoded = await getAuth().verifyIdToken(token);\n      } catch (e) {\n        unauthorized(res);\n        return;\n      }\n\n      (req as __RequestWithAuth).auth = decoded;\n\n      next();\n    },\n  };\n}\n\nfunction unauthorized(res: Response) {\n  res.status(403);\n  res.send('Unauthorized');\n  res.end();\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAkBA,kBAAwC;AAGxC,qBAAyC;AAgBlC,SAAS,aACd,QACA,QACqB;AACrB,+CAAyB;AACzB,QAAM,YAAW,iCAAQ,aAAY;AACrC,SAAO;AAAA,IACC,OAAO,MAA2B,OAAmB;AAAA;AAKzD,YAAI,YAAY,CAAC,MAAM;AACrB,gBAAM,IAAI,MAAM,kBAAkB;AAAA,QACpC;AAEA,eAAO,OAAO,MAAwB,KAAK;AAAA,MAC7C;AAAA;AAAA,IACM,SAAS,KAAK,KAAK,MAAM;AAAA;AAvDnC,YAAAA;AAwDM,cAAM,SAAQA,MAAA,IAAI,QAAQ,eAAe,MAA3B,gBAAAA,IAA8B,MAAM,cAAc;AAChE,YAAI;AAEJ,YAAI,CAAC,OAAO;AACV,cAAI,UAAU;AACZ,yBAAa,GAAG;AAAA,UAClB,OAAO;AACL,iBAAK;AAAA,UACP;AACA;AAAA,QACF;AACA,YAAI;AACF,oBAAU,UAAM,qBAAQ,EAAE,cAAc,KAAK;AAAA,QAC/C,SAAS,GAAG;AACV,uBAAa,GAAG;AAChB;AAAA,QACF;AAEA,QAAC,IAA0B,OAAO;AAElC,aAAK;AAAA,MACP;AAAA;AAAA,EACF;AACF;AAEA,SAAS,aAAa,KAAe;AACnC,MAAI,OAAO,GAAG;AACd,MAAI,KAAK,cAAc;AACvB,MAAI,IAAI;AACV;","names":["_a"]}