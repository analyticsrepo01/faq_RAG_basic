{"version":3,"sources":["../src/firestoreTraceStore.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { logger } from '@genkit-ai/core/logging';\nimport {\n  SpanData,\n  SpanDataSchema,\n  TraceData,\n  TraceDataSchema,\n  TraceQuery,\n  TraceQueryResponse,\n  TraceStore,\n} from '@genkit-ai/core/tracing';\nimport { Firestore } from '@google-cloud/firestore';\nimport { randomUUID } from 'crypto';\n\nconst DOC_MAX_SIZE = 1_000_000;\n\n/**\n * Firestore implementation of a trace store.\n */\nexport class FirestoreTraceStore implements TraceStore {\n  readonly db: Firestore;\n  readonly collection: string;\n  readonly databaseId: string;\n  readonly expireAfterDays: number;\n\n  constructor(\n    params: {\n      collection?: string;\n      databaseId?: string;\n      projectId?: string;\n      expireAfterDays?: number;\n    } = {}\n  ) {\n    this.collection = params.collection || 'genkit-traces';\n    this.databaseId = params.databaseId || '(default)';\n    this.expireAfterDays = params.expireAfterDays || 14;\n    this.db = new Firestore({\n      databaseId: this.databaseId,\n      ignoreUndefinedProperties: true,\n    });\n  }\n\n  async save(traceId: string, traceData: TraceData): Promise<void> {\n    const expireAt = Date.now() + this.expireAfterDays * 24 * 60 * 60 * 1000;\n    const traceInfo = {\n      ...traceData,\n      expireAt,\n      spans: {},\n    };\n    const start = Date.now();\n\n    const batches = rebatchSpans(traceData);\n\n    let batchWrite = this.db.batch();\n    batchWrite.set(\n      this.db.collection(this.collection).doc(traceId),\n      traceInfo,\n      { merge: true }\n    );\n    batches.forEach((batch) => {\n      batchWrite.create(\n        this.db\n          .collection(this.collection)\n          .doc(traceId)\n          .collection('spans')\n          .doc(randomUUID()),\n        {\n          expireAt,\n          spans: batch,\n        }\n      );\n    });\n    await batchWrite.commit();\n\n    logger.debug(\n      `saved trace ${traceId}, ${Object.keys(traceData.spans).length} span(s) (${Date.now() - start}ms)`\n    );\n  }\n\n  async load(traceId: string): Promise<TraceData | undefined> {\n    const [traceInfo, spanBatches] = await Promise.all([\n      this.db.collection(this.collection).doc(traceId).get(),\n      this.db\n        .collection(this.collection)\n        .doc(traceId)\n        .collection('spans')\n        .get(),\n    ]);\n    const spans: Record<string, SpanData> = {};\n    spanBatches.forEach((batch) => {\n      const spansBatch: Record<string, SpanData> = batch.data().spans;\n      Object.keys(spansBatch).forEach((key) => {\n        spans[key] = SpanDataSchema.parse(spansBatch[key]);\n      });\n    });\n    return TraceDataSchema.parse({\n      ...traceInfo.data(),\n      spans,\n    });\n  }\n\n  async list(query?: TraceQuery): Promise<TraceQueryResponse> {\n    const limit = query?.limit || 10;\n    let fsQuery = this.db\n      .collection(this.collection)\n      .orderBy('startTime', 'desc');\n    if (query?.continuationToken) {\n      fsQuery = fsQuery.startAfter(parseInt(query.continuationToken));\n    }\n    fsQuery = fsQuery.limit(limit);\n\n    const data = await fsQuery.get();\n    const lastVisible = data.docs[data.docs.length - 1];\n    return {\n      traces: data.docs.map((d) => d.data() as TraceData),\n      continuationToken:\n        data.docs.length === limit\n          ? `${lastVisible.data().startTime}`\n          : undefined,\n    };\n  }\n}\n\n/**\n * Batches up spans in the trace by size, trying to make sure each batch does not exceed firestore docs size limit.\n * Will truncate span if it's too big to fit into a batch by itself.\n * @internal\n */\nexport function rebatchSpans(traceData: TraceData): Record<string, SpanData>[] {\n  const batches: Record<string, SpanData>[] = [];\n  let lastBatchRunningSize = 0;\n  for (const span of Object.values(traceData.spans)) {\n    let estimatedSpanSize = estimateSpanSize(span);\n    if (estimatedSpanSize >= DOC_MAX_SIZE) {\n      logger.warn(\n        `Truncating data for trace ${traceData.traceId} span ${span.spanId}`\n      );\n      truncateSpanData(span);\n      estimatedSpanSize = estimateSpanSize(span);\n    }\n    if (lastBatchRunningSize + estimatedSpanSize < DOC_MAX_SIZE) {\n      // last batch is small enough, keep piling on...\n      if (batches.length === 0) {\n        batches.push({});\n      }\n    } else {\n      // last batch is too big, start a new one\n      batches.push({});\n      lastBatchRunningSize = 0;\n    }\n    lastBatchRunningSize += estimatedSpanSize;\n    batches[batches.length - 1][span.spanId] = span;\n  }\n  return batches;\n}\n\n/**\n * Estimates the data size of the span.\n * @internal\n */\nfunction estimateSpanSize(span: SpanData) {\n  if (Object.values(span.attributes).length === 0) {\n    return 0;\n  }\n  return Object.values(span.attributes)\n    .map((attr) => attr.toString().length)\n    .reduce((a, b) => a + b);\n}\n\nfunction truncateSpanData(span: SpanData) {\n  span.truncated = true;\n  // We fisrt see if deleting output does the trick (input might be useful for replayability)\n  delete span.attributes['genkit:output'];\n  if (estimateSpanSize(span) < DOC_MAX_SIZE) {\n    return;\n  }\n  delete span.attributes['genkit:input'];\n  if (estimateSpanSize(span) < DOC_MAX_SIZE) {\n    return;\n  }\n  // Nuclear option... maybe there's a better way? Not very likely though...\n  span.attributes = {};\n  return;\n}\n"],"mappings":"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","names":[]}