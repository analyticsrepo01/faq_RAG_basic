{"version":3,"sources":["../src/helpers.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { StreamingCallback } from '@genkit-ai/core';\nimport { getApps, initializeApp } from 'firebase-admin/app';\nimport { GoogleAuth } from 'google-auth-library';\n\n// cached `GoogleAuth` client.\nlet auth: GoogleAuth;\nfunction getAuthClient() {\n  // Lazy load GoogleAuth client.\n  if (!auth) {\n    auth = new GoogleAuth();\n  }\n  return auth;\n}\n\nconst streamDelimiter = '\\n';\n\nexport async function callHttpsFunction(\n  functionName: string,\n  location: string,\n  data: any,\n  streamingCallback?: StreamingCallback<any>\n) {\n  const auth = getAuthClient();\n  let funcUrl = await getFunctionUrl(functionName, location);\n  if (!funcUrl) {\n    throw new Error(`Unable to retrieve uri for function at ${functionName}`);\n  }\n  const tokenClient = await auth.getIdTokenClient(funcUrl);\n  const token = await tokenClient.idTokenProvider.fetchIdToken(funcUrl);\n\n  if (streamingCallback) {\n    funcUrl += '?stream=true';\n  }\n\n  const res = await fetch(funcUrl, {\n    method: 'POST',\n    body: JSON.stringify(data),\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${token}`,\n    },\n  });\n\n  if (streamingCallback) {\n    const reader = res.body!.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    while (true) {\n      const result = await reader.read();\n      const decodedValue = decoder.decode(result.value);\n      if (decodedValue) {\n        buffer += decodedValue;\n      }\n      // If buffer includes the delimiter that means we are still recieving chunks.\n      while (buffer.includes(streamDelimiter)) {\n        streamingCallback(\n          JSON.parse(buffer.substring(0, buffer.indexOf(streamDelimiter)))\n        );\n        buffer = buffer.substring(\n          buffer.indexOf(streamDelimiter) + streamDelimiter.length\n        );\n      }\n      if (result.done) {\n        return buffer;\n      }\n    }\n  }\n  const responseText = await res.text();\n  return responseText;\n}\n\nconst functionUrlCache = {} as Record<string, string>;\n\nexport async function getFunctionUrl(name, location) {\n  if (functionUrlCache[name]) {\n    return functionUrlCache[name];\n  }\n  const auth = getAuthClient();\n  const projectId = await auth.getProjectId();\n  const url =\n    'https://cloudfunctions.googleapis.com/v2beta/' +\n    `projects/${projectId}/locations/${location}/functions/${name}`;\n\n  const client = await auth.getClient();\n  const res = (await client.request({ url })) as any;\n  const uri = res.data?.serviceConfig?.uri;\n  if (!uri) {\n    throw new Error(`Unable to retrieve uri for function at ${url}`);\n  }\n  functionUrlCache[name] = uri;\n  return uri;\n}\n\n/**\n * Extracts error message from the given error object, or if input is not an error then just turn the error into a string.\n */\nexport function getErrorMessage(e: any): string {\n  if (e instanceof Error) {\n    return e.message;\n  }\n  return `${e}`;\n}\n\n/**\n * Extracts stack trace from the given error object, or if input is not an error then returns undefined.\n */\nexport function getErrorStack(e: any): string | undefined {\n  if (e instanceof Error) {\n    return e.stack;\n  }\n  return undefined;\n}\n\nexport function getLocation() {\n  return process.env['GCLOUD_LOCATION'] || 'us-central1';\n}\n\nexport function initializeAppIfNecessary() {\n  if (!getApps().length) {\n    initializeApp();\n  }\n}\n"],"mappings":";;;AAiBA,SAAS,SAAS,qBAAqB;AACvC,SAAS,kBAAkB;AAG3B,IAAI;AACJ,SAAS,gBAAgB;AAEvB,MAAI,CAAC,MAAM;AACT,WAAO,IAAI,WAAW;AAAA,EACxB;AACA,SAAO;AACT;AAEA,MAAM,kBAAkB;AAExB,SAAsB,kBACpB,cACA,UACA,MACA,mBACA;AAAA;AACA,UAAMA,QAAO,cAAc;AAC3B,QAAI,UAAU,MAAM,eAAe,cAAc,QAAQ;AACzD,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,0CAA0C,YAAY,EAAE;AAAA,IAC1E;AACA,UAAM,cAAc,MAAMA,MAAK,iBAAiB,OAAO;AACvD,UAAM,QAAQ,MAAM,YAAY,gBAAgB,aAAa,OAAO;AAEpE,QAAI,mBAAmB;AACrB,iBAAW;AAAA,IACb;AAEA,UAAM,MAAM,MAAM,MAAM,SAAS;AAAA,MAC/B,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,IAAI;AAAA,MACzB,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,eAAe,UAAU,KAAK;AAAA,MAChC;AAAA,IACF,CAAC;AAED,QAAI,mBAAmB;AACrB,YAAM,SAAS,IAAI,KAAM,UAAU;AACnC,YAAM,UAAU,IAAI,YAAY;AAChC,UAAI,SAAS;AACb,aAAO,MAAM;AACX,cAAM,SAAS,MAAM,OAAO,KAAK;AACjC,cAAM,eAAe,QAAQ,OAAO,OAAO,KAAK;AAChD,YAAI,cAAc;AAChB,oBAAU;AAAA,QACZ;AAEA,eAAO,OAAO,SAAS,eAAe,GAAG;AACvC;AAAA,YACE,KAAK,MAAM,OAAO,UAAU,GAAG,OAAO,QAAQ,eAAe,CAAC,CAAC;AAAA,UACjE;AACA,mBAAS,OAAO;AAAA,YACd,OAAO,QAAQ,eAAe,IAAI,gBAAgB;AAAA,UACpD;AAAA,QACF;AACA,YAAI,OAAO,MAAM;AACf,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,UAAM,eAAe,MAAM,IAAI,KAAK;AACpC,WAAO;AAAA,EACT;AAAA;AAEA,MAAM,mBAAmB,CAAC;AAE1B,SAAsB,eAAe,MAAM,UAAU;AAAA;AAzFrD;AA0FE,QAAI,iBAAiB,IAAI,GAAG;AAC1B,aAAO,iBAAiB,IAAI;AAAA,IAC9B;AACA,UAAMA,QAAO,cAAc;AAC3B,UAAM,YAAY,MAAMA,MAAK,aAAa;AAC1C,UAAM,MACJ,yDACY,SAAS,cAAc,QAAQ,cAAc,IAAI;AAE/D,UAAM,SAAS,MAAMA,MAAK,UAAU;AACpC,UAAM,MAAO,MAAM,OAAO,QAAQ,EAAE,IAAI,CAAC;AACzC,UAAM,OAAM,eAAI,SAAJ,mBAAU,kBAAV,mBAAyB;AACrC,QAAI,CAAC,KAAK;AACR,YAAM,IAAI,MAAM,0CAA0C,GAAG,EAAE;AAAA,IACjE;AACA,qBAAiB,IAAI,IAAI;AACzB,WAAO;AAAA,EACT;AAAA;AAKO,SAAS,gBAAgB,GAAgB;AAC9C,MAAI,aAAa,OAAO;AACtB,WAAO,EAAE;AAAA,EACX;AACA,SAAO,GAAG,CAAC;AACb;AAKO,SAAS,cAAc,GAA4B;AACxD,MAAI,aAAa,OAAO;AACtB,WAAO,EAAE;AAAA,EACX;AACA,SAAO;AACT;AAEO,SAAS,cAAc;AAC5B,SAAO,QAAQ,IAAI,iBAAiB,KAAK;AAC3C;AAEO,SAAS,2BAA2B;AACzC,MAAI,CAAC,QAAQ,EAAE,QAAQ;AACrB,kBAAc;AAAA,EAChB;AACF;","names":["auth"]}