"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var imagen_exports = {};
__export(imagen_exports, {
  imagen2: () => imagen2,
  imagen2Model: () => imagen2Model
});
module.exports = __toCommonJS(imagen_exports);
var import_model = require("@genkit-ai/ai/model");
var import_zod = __toESM(require("zod"));
var import_predict = require("./predict.js");
const ImagenConfigSchema = import_model.GenerationCommonConfigSchema.extend({
  /** Language of the prompt text. */
  language: import_zod.default.enum(["auto", "en", "es", "hi", "ja", "ko", "pt", "zh-TW", "zh", "zh-CN"]).optional(),
  /** Desired aspect ratio of output image. */
  aspectRatio: import_zod.default.enum(["1:1", "9:16", "16:9"]).optional(),
  /** A negative prompt to help generate the images. For example: "animals" (removes animals), "blurry" (makes the image clearer), "text" (removes text), or "cropped" (removes cropped images). */
  negativePrompt: import_zod.default.string().optional(),
  /** Any non-negative integer you provide to make output images deterministic. Providing the same seed number always results in the same output images. Accepted integer values: 1 - 2147483647. */
  seed: import_zod.default.number().optional()
});
const imagen2 = (0, import_model.modelRef)({
  name: "vertexai/imagen2",
  info: {
    label: "Vertex AI - Imagen2",
    supports: {
      media: false,
      multiturn: false,
      tools: false,
      systemRole: false,
      output: ["media"]
    }
  },
  configSchema: ImagenConfigSchema
});
function extractText(request) {
  return request.messages.at(-1).content.map((c) => c.text || "").join("");
}
function toParameters(request) {
  var _a, _b, _c, _d, _e;
  const out = {
    sampleCount: (_a = request.candidates) != null ? _a : 1,
    aspectRatio: (_b = request.config) == null ? void 0 : _b.aspectRatio,
    negativePrompt: (_c = request.config) == null ? void 0 : _c.negativePrompt,
    seed: (_d = request.config) == null ? void 0 : _d.seed,
    language: (_e = request.config) == null ? void 0 : _e.language
  };
  for (const k in out) {
    if (!out[k])
      delete out[k];
  }
  return out;
}
function extractPromptImage(request) {
  var _a, _b, _c;
  return (_c = (_b = (_a = request.messages.at(-1)) == null ? void 0 : _a.content.find((p) => !!p.media)) == null ? void 0 : _b.media) == null ? void 0 : _c.url.split(",")[1];
}
function imagen2Model(client, options) {
  const predict = (0, import_predict.predictModel)(client, options, "imagegeneration@005");
  return (0, import_model.defineModel)(
    __spreadProps(__spreadValues({
      name: imagen2.name
    }, imagen2.info), {
      configSchema: ImagenConfigSchema
    }),
    (request) => __async(this, null, function* () {
      const instance = {
        prompt: extractText(request)
      };
      if (extractPromptImage(request))
        instance.image = { bytesBase64Encoded: extractPromptImage(request) };
      const req = {
        instances: [instance],
        parameters: toParameters(request)
      };
      const response = yield predict([instance], toParameters(request));
      const candidates = response.predictions.map((p, i) => {
        const b64data = p.bytesBase64Encoded;
        const mimeType = p.mimeType;
        return {
          index: i,
          finishReason: "stop",
          message: {
            role: "model",
            content: [
              {
                media: {
                  url: `data:${mimeType};base64,${b64data}`,
                  contentType: mimeType
                }
              }
            ]
          }
        };
      });
      return {
        candidates,
        usage: __spreadProps(__spreadValues({}, (0, import_model.getBasicUsageStats)(request.messages, candidates)), {
          custom: { generations: candidates.length }
        }),
        custom: response
      };
    })
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  imagen2,
  imagen2Model
});
//# sourceMappingURL=imagen.js.map