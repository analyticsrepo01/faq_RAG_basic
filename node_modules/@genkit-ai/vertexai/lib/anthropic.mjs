import {
  __async,
  __forAwait,
  __spreadProps,
  __spreadValues
} from "./chunk-WFI2LP4G.mjs";
import { AnthropicVertex } from "@anthropic-ai/vertex-sdk";
import {
  GenerationCommonConfigSchema,
  defineModel,
  getBasicUsageStats,
  modelRef
} from "@genkit-ai/ai/model";
import { GENKIT_CLIENT_HEADER } from "@genkit-ai/core";
const claude3Sonnet = modelRef({
  name: "vertexai/claude-3-sonnet",
  info: {
    label: "Vertex AI Model Garden - Claude 3 Sonnet",
    versions: ["claude-3-sonnet@20240229"],
    supports: {
      multiturn: true,
      media: true,
      tools: false,
      systemRole: true,
      output: ["text"]
    }
  },
  configSchema: GenerationCommonConfigSchema
});
const claude3Haiku = modelRef({
  name: "vertexai/claude-3-haiku",
  info: {
    label: "Vertex AI Model Garden - Claude 3 Haiku",
    versions: ["claude-3-haiku@20240307"],
    supports: {
      multiturn: true,
      media: true,
      tools: false,
      systemRole: true,
      output: ["text"]
    }
  },
  configSchema: GenerationCommonConfigSchema
});
const claude3Opus = modelRef({
  name: "vertexai/claude-3-opus",
  info: {
    label: "Vertex AI Model Garden - Claude 3 Opus",
    versions: ["claude-3-opus@20240229"],
    supports: {
      multiturn: true,
      media: true,
      tools: false,
      systemRole: true,
      output: ["text"]
    }
  },
  configSchema: GenerationCommonConfigSchema
});
const SUPPORTED_ANTHROPIC_MODELS = {
  "claude-3-sonnet": claude3Sonnet,
  "claude-3-opus": claude3Opus,
  "claude-3-haiku": claude3Haiku
};
function anthropicModel(modelName, projectId, region) {
  var _a, _b, _c;
  const client = new AnthropicVertex({
    region,
    projectId,
    defaultHeaders: {
      "X-Goog-Api-Client": GENKIT_CLIENT_HEADER
    }
  });
  const model = SUPPORTED_ANTHROPIC_MODELS[modelName];
  if (!model) {
    throw new Error(`unsupported Anthropic model name ${modelName}`);
  }
  return defineModel(
    {
      name: model.name,
      label: (_a = model.info) == null ? void 0 : _a.label,
      configSchema: GenerationCommonConfigSchema,
      supports: (_b = model.info) == null ? void 0 : _b.supports,
      versions: (_c = model.info) == null ? void 0 : _c.versions
    },
    (input, streamingCallback) => __async(this, null, function* () {
      var _a2, _b2, _c2, _d;
      if (!streamingCallback) {
        const response = yield client.messages.create(__spreadProps(__spreadValues({}, toAnthropicRequest((_b2 = (_a2 = input.config) == null ? void 0 : _a2.version) != null ? _b2 : modelName, input)), {
          stream: false
        }));
        return fromAnthropicResponse(input, response);
      } else {
        const stream = yield client.messages.stream(
          toAnthropicRequest((_d = (_c2 = input.config) == null ? void 0 : _c2.version) != null ? _d : modelName, input)
        );
        try {
          for (var iter = __forAwait(stream), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const event = temp.value;
            if (event.type === "content_block_delta") {
              streamingCallback({
                index: 0,
                content: [
                  {
                    text: event.delta.text
                  }
                ]
              });
            }
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        return fromAnthropicResponse(input, yield stream.finalMessage());
      }
    })
  );
}
function toAnthropicRequest(model, input) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  let system = void 0;
  const messages = [];
  for (const msg of input.messages) {
    if (msg.role === "system") {
      system = msg.content.map((c) => {
        if (!c.text) {
          throw new Error(
            "Only text context is supported for system messages."
          );
        }
        return c.text;
      }).join();
    } else {
      messages.push({
        role: toAnthropicRole(msg.role),
        content: toAnthropicContent(msg.content)
      });
    }
  }
  const request = {
    model,
    messages,
    // https://docs.anthropic.com/claude/docs/models-overview#model-comparison
    max_tokens: (_b = (_a = input.config) == null ? void 0 : _a.maxOutputTokens) != null ? _b : 4096
  };
  if (system) {
    request["system"] = system;
  }
  if ((_c = input.config) == null ? void 0 : _c.stopSequences) {
    request.stop_sequences = (_d = input.config) == null ? void 0 : _d.stopSequences;
  }
  if ((_e = input.config) == null ? void 0 : _e.temperature) {
    request.temperature = (_f = input.config) == null ? void 0 : _f.temperature;
  }
  if ((_g = input.config) == null ? void 0 : _g.topK) {
    request.top_k = (_h = input.config) == null ? void 0 : _h.topK;
  }
  if ((_i = input.config) == null ? void 0 : _i.topP) {
    request.top_p = (_j = input.config) == null ? void 0 : _j.topP;
  }
  return request;
}
function toAnthropicContent(content) {
  return content.map((p) => {
    if (p.text) {
      return {
        type: "text",
        text: p.text
      };
    }
    if (p.media) {
      let b64Data = p.media.url;
      if (b64Data.startsWith("data:")) {
        b64Data = b64Data.substring(b64Data.indexOf(",") + 1);
      }
      return {
        type: "image",
        source: {
          type: "base64",
          data: b64Data,
          media_type: p.media.contentType
        }
      };
    }
    throw new Error(`Unsupported content type: ${p}`);
  });
}
function toAnthropicRole(role) {
  if (role === "model") {
    return "assistant";
  }
  if (role === "user") {
    return "user";
  }
  throw new Error(`Unsupported role type ${role}`);
}
function fromAnthropicResponse(input, response) {
  const candidates = [
    {
      index: 0,
      finishReason: toGenkitFinishReason(response.stop_reason),
      custom: {
        id: response.id,
        model: response.model,
        type: response.type
      },
      message: {
        role: "model",
        content: response.content.map((c) => ({ text: c.text }))
      }
    }
  ];
  return {
    candidates,
    usage: __spreadProps(__spreadValues({}, getBasicUsageStats(input.messages, candidates)), {
      inputTokens: response.usage.input_tokens,
      outputTokens: response.usage.output_tokens
    })
  };
}
function toGenkitFinishReason(reason) {
  switch (reason) {
    case "end_turn":
      return "stop";
    case "max_tokens":
      return "length";
    case "stop_sequence":
      return "stop";
    case null:
      return "unknown";
    default:
      return "other";
  }
}
export {
  SUPPORTED_ANTHROPIC_MODELS,
  anthropicModel,
  claude3Haiku,
  claude3Opus,
  claude3Sonnet,
  fromAnthropicResponse,
  toAnthropicRequest
};
//# sourceMappingURL=anthropic.mjs.map