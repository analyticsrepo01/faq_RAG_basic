"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var evaluation_exports = {};
__export(evaluation_exports, {
  VertexAIEvaluationMetricType: () => VertexAIEvaluationMetricType,
  vertexEvaluators: () => vertexEvaluators
});
module.exports = __toCommonJS(evaluation_exports);
var import_zod = __toESM(require("zod"));
var import_evaluator_factory = require("./evaluator_factory.js");
var VertexAIEvaluationMetricType = /* @__PURE__ */ ((VertexAIEvaluationMetricType2) => {
  VertexAIEvaluationMetricType2["BLEU"] = "BLEU";
  VertexAIEvaluationMetricType2["ROUGE"] = "ROUGE";
  VertexAIEvaluationMetricType2["FLUENCY"] = "FLEUNCY";
  VertexAIEvaluationMetricType2["SAFETY"] = "SAFETY";
  VertexAIEvaluationMetricType2["GROUNDEDNESS"] = "GROUNDEDNESS";
  VertexAIEvaluationMetricType2["SUMMARIZATION_QUALITY"] = "SUMMARIZATION_QUALITY";
  VertexAIEvaluationMetricType2["SUMMARIZATION_HELPFULNESS"] = "SUMMARIZATION_HELPFULNESS";
  VertexAIEvaluationMetricType2["SUMMARIZATION_VERBOSITY"] = "SUMMARIZATION_VERBOSITY";
  return VertexAIEvaluationMetricType2;
})(VertexAIEvaluationMetricType || {});
function vertexEvaluators(auth, metrics, projectId, location) {
  const factory = new import_evaluator_factory.EvaluatorFactory(auth, location, projectId);
  return metrics.map((metric) => {
    const metricType = isConfig(metric) ? metric.type : metric;
    const metricSpec = isConfig(metric) ? metric.metricSpec : {};
    switch (metricType) {
      case "BLEU" /* BLEU */: {
        return createBleuEvaluator(factory, metricSpec);
      }
      case "ROUGE" /* ROUGE */: {
        return createRougeEvaluator(factory, metricSpec);
      }
      case "FLEUNCY" /* FLUENCY */: {
        return createFluencyEvaluator(factory, metricSpec);
      }
      case "SAFETY" /* SAFETY */: {
        return createSafetyEvaluator(factory, metricSpec);
      }
      case "GROUNDEDNESS" /* GROUNDEDNESS */: {
        return createGroundednessEvaluator(factory, metricSpec);
      }
      case "SUMMARIZATION_QUALITY" /* SUMMARIZATION_QUALITY */: {
        return createSummarizationQualityEvaluator(factory, metricSpec);
      }
      case "SUMMARIZATION_HELPFULNESS" /* SUMMARIZATION_HELPFULNESS */: {
        return createSummarizationHelpfulnessEvaluator(factory, metricSpec);
      }
      case "SUMMARIZATION_VERBOSITY" /* SUMMARIZATION_VERBOSITY */: {
        return createSummarizationVerbosityEvaluator(factory, metricSpec);
      }
    }
  });
}
function isConfig(config) {
  return config.type !== void 0;
}
const BleuResponseSchema = import_zod.default.object({
  bleuResults: import_zod.default.object({
    bleuMetricValues: import_zod.default.array(import_zod.default.object({ score: import_zod.default.number() }))
  })
});
function createBleuEvaluator(factory, metricSpec) {
  return factory.create(
    {
      metric: "BLEU" /* BLEU */,
      displayName: "BLEU",
      definition: "Computes the BLEU score by comparing the output against the ground truth",
      responseSchema: BleuResponseSchema
    },
    (datapoint) => {
      return {
        bleuInput: {
          metricSpec,
          instances: [
            {
              prediction: datapoint.output,
              reference: datapoint.reference
            }
          ]
        }
      };
    },
    (response) => {
      return {
        score: response.bleuResults.bleuMetricValues[0].score
      };
    }
  );
}
const RougeResponseSchema = import_zod.default.object({
  rougeResults: import_zod.default.object({
    rougeMetricValues: import_zod.default.array(import_zod.default.object({ score: import_zod.default.number() }))
  })
});
function createRougeEvaluator(factory, metricSpec) {
  return factory.create(
    {
      metric: "ROUGE" /* ROUGE */,
      displayName: "ROUGE",
      definition: "Computes the ROUGE score by comparing the output against the ground truth",
      responseSchema: RougeResponseSchema
    },
    (datapoint) => {
      return {
        rougeInput: {
          metricSpec,
          instances: {
            prediction: datapoint.output,
            reference: datapoint.reference
          }
        }
      };
    },
    (response) => {
      return {
        score: response.rougeResults.rougeMetricValues[0].score
      };
    }
  );
}
const FluencyResponseSchema = import_zod.default.object({
  fluencyResult: import_zod.default.object({
    score: import_zod.default.number(),
    explanation: import_zod.default.string(),
    confidence: import_zod.default.number()
  })
});
function createFluencyEvaluator(factory, metricSpec) {
  return factory.create(
    {
      metric: "FLEUNCY" /* FLUENCY */,
      displayName: "Fluency",
      definition: "Assesses the language mastery of an output",
      responseSchema: FluencyResponseSchema
    },
    (datapoint) => {
      return {
        fluencyInput: {
          metricSpec,
          instance: {
            prediction: datapoint.output
          }
        }
      };
    },
    (response) => {
      return {
        score: response.fluencyResult.score,
        details: {
          reasoning: response.fluencyResult.explanation
        }
      };
    }
  );
}
const SafetyResponseSchema = import_zod.default.object({
  safetyResult: import_zod.default.object({
    score: import_zod.default.number(),
    explanation: import_zod.default.string(),
    confidence: import_zod.default.number()
  })
});
function createSafetyEvaluator(factory, metricSpec) {
  return factory.create(
    {
      metric: "SAFETY" /* SAFETY */,
      displayName: "Safety",
      definition: "Assesses the level of safety of an output",
      responseSchema: SafetyResponseSchema
    },
    (datapoint) => {
      return {
        safetyInput: {
          metricSpec,
          instance: {
            prediction: datapoint.output
          }
        }
      };
    },
    (response) => {
      return {
        score: response.safetyResult.score,
        details: {
          reasoning: response.safetyResult.explanation
        }
      };
    }
  );
}
const GroundednessResponseSchema = import_zod.default.object({
  groundednessResult: import_zod.default.object({
    score: import_zod.default.number(),
    explanation: import_zod.default.string(),
    confidence: import_zod.default.number()
  })
});
function createGroundednessEvaluator(factory, metricSpec) {
  return factory.create(
    {
      metric: "GROUNDEDNESS" /* GROUNDEDNESS */,
      displayName: "Groundedness",
      definition: "Assesses the ability to provide or reference information included only in the context",
      responseSchema: GroundednessResponseSchema
    },
    (datapoint) => {
      var _a;
      return {
        groundednessInput: {
          metricSpec,
          instance: {
            prediction: datapoint.output,
            context: (_a = datapoint.context) == null ? void 0 : _a.join(". ")
          }
        }
      };
    },
    (response) => {
      return {
        score: response.groundednessResult.score,
        details: {
          reasoning: response.groundednessResult.explanation
        }
      };
    }
  );
}
const SummarizationQualityResponseSchema = import_zod.default.object({
  summarizationQualityResult: import_zod.default.object({
    score: import_zod.default.number(),
    explanation: import_zod.default.string(),
    confidence: import_zod.default.number()
  })
});
function createSummarizationQualityEvaluator(factory, metricSpec) {
  return factory.create(
    {
      metric: "SUMMARIZATION_QUALITY" /* SUMMARIZATION_QUALITY */,
      displayName: "Summarization quality",
      definition: "Assesses the overall ability to summarize text",
      responseSchema: SummarizationQualityResponseSchema
    },
    (datapoint) => {
      var _a;
      return {
        summarizationQualityInput: {
          metricSpec,
          instance: {
            prediction: datapoint.output,
            instruction: datapoint.input,
            context: (_a = datapoint.context) == null ? void 0 : _a.join(". ")
          }
        }
      };
    },
    (response) => {
      return {
        score: response.summarizationQualityResult.score,
        details: {
          reasoning: response.summarizationQualityResult.explanation
        }
      };
    }
  );
}
const SummarizationHelpfulnessResponseSchema = import_zod.default.object({
  summarizationHelpfulnessResult: import_zod.default.object({
    score: import_zod.default.number(),
    explanation: import_zod.default.string(),
    confidence: import_zod.default.number()
  })
});
function createSummarizationHelpfulnessEvaluator(factory, metricSpec) {
  return factory.create(
    {
      metric: "SUMMARIZATION_HELPFULNESS" /* SUMMARIZATION_HELPFULNESS */,
      displayName: "Summarization helpfulness",
      definition: "Assesses the ability to provide a summarization, which contains the details necessary to substitute the original text",
      responseSchema: SummarizationHelpfulnessResponseSchema
    },
    (datapoint) => {
      var _a;
      return {
        summarizationHelpfulnessInput: {
          metricSpec,
          instance: {
            prediction: datapoint.output,
            instruction: datapoint.input,
            context: (_a = datapoint.context) == null ? void 0 : _a.join(". ")
          }
        }
      };
    },
    (response) => {
      return {
        score: response.summarizationHelpfulnessResult.score,
        details: {
          reasoning: response.summarizationHelpfulnessResult.explanation
        }
      };
    }
  );
}
const SummarizationVerbositySchema = import_zod.default.object({
  summarizationVerbosityResult: import_zod.default.object({
    score: import_zod.default.number(),
    explanation: import_zod.default.string(),
    confidence: import_zod.default.number()
  })
});
function createSummarizationVerbosityEvaluator(factory, metricSpec) {
  return factory.create(
    {
      metric: "SUMMARIZATION_VERBOSITY" /* SUMMARIZATION_VERBOSITY */,
      displayName: "Summarization verbosity",
      definition: "Aassess the ability to provide a succinct summarization",
      responseSchema: SummarizationVerbositySchema
    },
    (datapoint) => {
      var _a;
      return {
        summarizationVerbosityInput: {
          metricSpec,
          instance: {
            prediction: datapoint.output,
            instruction: datapoint.input,
            context: (_a = datapoint.context) == null ? void 0 : _a.join(". ")
          }
        }
      };
    },
    (response) => {
      return {
        score: response.summarizationVerbosityResult.score,
        details: {
          reasoning: response.summarizationVerbosityResult.explanation
        }
      };
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VertexAIEvaluationMetricType,
  vertexEvaluators
});
//# sourceMappingURL=evaluation.js.map