"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var src_exports = {};
__export(src_exports, {
  VertexAIEvaluationMetricType: () => import_evaluation.VertexAIEvaluationMetricType,
  claude3Haiku: () => import_anthropic.claude3Haiku,
  claude3Opus: () => import_anthropic.claude3Opus,
  claude3Sonnet: () => import_anthropic.claude3Sonnet,
  default: () => src_default,
  gemini15FlashPreview: () => import_gemini.gemini15FlashPreview,
  gemini15ProPreview: () => import_gemini.gemini15ProPreview,
  geminiPro: () => import_gemini.geminiPro,
  geminiProVision: () => import_gemini.geminiProVision,
  imagen2: () => import_imagen.imagen2,
  textEmbeddingGecko: () => import_embedder.textEmbeddingGecko,
  vertexAI: () => vertexAI
});
module.exports = __toCommonJS(src_exports);
var import_core = require("@genkit-ai/core");
var import_vertexai = require("@google-cloud/vertexai");
var import_google_auth_library = require("google-auth-library");
var import_anthropic = require("./anthropic.js");
var import_embedder = require("./embedder.js");
var import_evaluation = require("./evaluation.js");
var import_gemini = require("./gemini.js");
var import_imagen = require("./imagen.js");
const vertexAI = (0, import_core.genkitPlugin)(
  "vertexai",
  (options) => __async(void 0, null, function* () {
    const authClient = new import_google_auth_library.GoogleAuth(options == null ? void 0 : options.googleAuth);
    const projectId = (options == null ? void 0 : options.projectId) || (yield authClient.getProjectId());
    const location = (options == null ? void 0 : options.location) || "us-central1";
    const confError = (parameter, envVariableName) => {
      return new Error(
        `VertexAI Plugin is missing the '${parameter}' configuration. Please set the '${envVariableName}' environment variable or explicitly pass '${parameter}' into genkit config.`
      );
    };
    if (!location) {
      throw confError("location", "GCLOUD_LOCATION");
    }
    if (!projectId) {
      throw confError("project", "GCLOUD_PROJECT");
    }
    const vertexClient = new import_vertexai.VertexAI({
      project: projectId,
      location,
      googleAuthOptions: options == null ? void 0 : options.googleAuth
    });
    const metrics = (options == null ? void 0 : options.evaluation) && options.evaluation.metrics.length > 0 ? options.evaluation.metrics : [];
    const models = [
      (0, import_imagen.imagen2Model)(authClient, { projectId, location }),
      ...Object.keys(import_gemini.SUPPORTED_GEMINI_MODELS).map(
        (name) => (0, import_gemini.geminiModel)(name, vertexClient)
      )
    ];
    if (options == null ? void 0 : options.modelGardenModels) {
      options == null ? void 0 : options.modelGardenModels.forEach((m) => {
        const entry = Object.entries(import_anthropic.SUPPORTED_ANTHROPIC_MODELS).find(
          ([_, value]) => value.name === m.name
        );
        if (!entry) {
          throw new Error(`Unsupported model garden model: ${m.name}`);
        }
        models.push((0, import_anthropic.anthropicModel)(entry[0], projectId, location));
      });
    }
    return {
      models,
      embedders: [
        ...Object.keys(import_embedder.SUPPORTED_EMBEDDER_MODELS).map(
          (name) => (0, import_embedder.textEmbeddingGeckoEmbedder)(name, authClient, { projectId, location })
        )
      ],
      evaluators: (0, import_evaluation.vertexEvaluators)(authClient, metrics, projectId, location)
    };
  })
);
var src_default = vertexAI;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VertexAIEvaluationMetricType,
  claude3Haiku,
  claude3Opus,
  claude3Sonnet,
  gemini15FlashPreview,
  gemini15ProPreview,
  geminiPro,
  geminiProVision,
  imagen2,
  textEmbeddingGecko,
  vertexAI
});
//# sourceMappingURL=index.js.map