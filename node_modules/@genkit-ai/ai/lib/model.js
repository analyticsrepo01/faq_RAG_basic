"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var model_exports = {};
__export(model_exports, {
  CandidateErrorSchema: () => CandidateErrorSchema,
  CandidateSchema: () => CandidateSchema,
  DataPartSchema: () => DataPartSchema,
  GenerateRequestSchema: () => GenerateRequestSchema,
  GenerateResponseChunkSchema: () => GenerateResponseChunkSchema,
  GenerateResponseSchema: () => GenerateResponseSchema,
  GenerationCommonConfigSchema: () => GenerationCommonConfigSchema,
  GenerationUsageSchema: () => GenerationUsageSchema,
  MediaPartSchema: () => MediaPartSchema,
  MessageSchema: () => MessageSchema,
  ModelInfoSchema: () => ModelInfoSchema,
  PartSchema: () => PartSchema,
  RoleSchema: () => RoleSchema,
  TextPartSchema: () => TextPartSchema,
  ToolDefinitionSchema: () => ToolDefinitionSchema,
  ToolRequestPartSchema: () => ToolRequestPartSchema,
  ToolResponsePartSchema: () => ToolResponsePartSchema,
  defineModel: () => defineModel,
  getBasicUsageStats: () => getBasicUsageStats,
  modelRef: () => modelRef
});
module.exports = __toCommonJS(model_exports);
var import_core = require("@genkit-ai/core");
var import_schema = require("@genkit-ai/core/schema");
var import_node_perf_hooks = require("node:perf_hooks");
var import_zod = require("zod");
var import_document = require("./document.js");
var import_middleware = require("./model/middleware.js");
var telemetry = __toESM(require("./telemetry.js"));
const EmptyPartSchema = import_zod.z.object({
  text: import_zod.z.never().optional(),
  media: import_zod.z.never().optional(),
  toolRequest: import_zod.z.never().optional(),
  toolResponse: import_zod.z.never().optional(),
  data: import_zod.z.unknown().optional(),
  metadata: import_zod.z.record(import_zod.z.unknown()).optional()
});
const TextPartSchema = EmptyPartSchema.extend({
  /** The text of the message. */
  text: import_zod.z.string()
});
const MediaPartSchema = EmptyPartSchema.extend({
  media: import_zod.z.object({
    /** The media content type. Inferred from data uri if not provided. */
    contentType: import_zod.z.string().optional(),
    /** A `data:` or `https:` uri containing the media content.  */
    url: import_zod.z.string()
  })
});
const ToolRequestPartSchema = EmptyPartSchema.extend({
  /** A request for a tool to be executed, usually provided by a model. */
  toolRequest: import_zod.z.object({
    /** The call id or reference for a specific request. */
    ref: import_zod.z.string().optional(),
    /** The name of the tool to call. */
    name: import_zod.z.string(),
    /** The input parameters for the tool, usually a JSON object. */
    input: import_zod.z.unknown().optional()
  })
});
const ToolResponsePartSchema = EmptyPartSchema.extend({
  /** A provided response to a tool call. */
  toolResponse: import_zod.z.object({
    /** The call id or reference for a specific request. */
    ref: import_zod.z.string().optional(),
    /** The name of the tool. */
    name: import_zod.z.string(),
    /** The output data returned from the tool, usually a JSON object. */
    output: import_zod.z.unknown().optional()
  })
});
const DataPartSchema = EmptyPartSchema.extend({
  data: import_zod.z.unknown()
});
const PartSchema = import_zod.z.union([
  TextPartSchema,
  MediaPartSchema,
  ToolRequestPartSchema,
  ToolResponsePartSchema,
  DataPartSchema
]);
const RoleSchema = import_zod.z.enum(["system", "user", "model", "tool"]);
const MessageSchema = import_zod.z.object({
  role: RoleSchema,
  content: import_zod.z.array(PartSchema)
});
const OutputFormatSchema = import_zod.z.enum(["json", "text", "media"]);
const ModelInfoSchema = import_zod.z.object({
  /** Acceptable names for this model (e.g. different versions). */
  versions: import_zod.z.array(import_zod.z.string()).optional(),
  /** Friendly label for this model (e.g. "Google AI - Gemini Pro") */
  label: import_zod.z.string().optional(),
  /** Supported model capabilities. */
  supports: import_zod.z.object({
    /** Model can process historical messages passed with a prompt. */
    multiturn: import_zod.z.boolean().optional(),
    /** Model can process media as part of the prompt (multimodal input). */
    media: import_zod.z.boolean().optional(),
    /** Model can perform tool calls. */
    tools: import_zod.z.boolean().optional(),
    /** Model can accept messages with role "system". */
    systemRole: import_zod.z.boolean().optional(),
    /** Model can output this type of data. */
    output: import_zod.z.array(OutputFormatSchema).optional(),
    /** Model can natively support document-based context grounding. */
    context: import_zod.z.boolean().optional()
  }).optional()
});
const ToolDefinitionSchema = import_zod.z.object({
  name: import_zod.z.string(),
  description: import_zod.z.string(),
  inputSchema: import_zod.z.record(import_zod.z.any()).describe("Valid JSON Schema representing the input of the tool."),
  outputSchema: import_zod.z.record(import_zod.z.any()).describe("Valid JSON Schema describing the output of the tool.").optional()
});
const GenerationCommonConfigSchema = import_zod.z.object({
  /** A specific version of a model family, e.g. `gemini-1.0-pro-001` for the `gemini-1.0-pro` family. */
  version: import_zod.z.string().optional(),
  temperature: import_zod.z.number().optional(),
  maxOutputTokens: import_zod.z.number().optional(),
  topK: import_zod.z.number().optional(),
  topP: import_zod.z.number().optional(),
  stopSequences: import_zod.z.array(import_zod.z.string()).optional()
});
const OutputConfigSchema = import_zod.z.object({
  format: OutputFormatSchema.optional(),
  schema: import_zod.z.record(import_zod.z.any()).optional()
});
const GenerateRequestSchema = import_zod.z.object({
  messages: import_zod.z.array(MessageSchema),
  config: import_zod.z.any().optional(),
  tools: import_zod.z.array(ToolDefinitionSchema).optional(),
  output: OutputConfigSchema.optional(),
  context: import_zod.z.array(import_document.DocumentDataSchema).optional(),
  candidates: import_zod.z.number().optional()
});
const GenerationUsageSchema = import_zod.z.object({
  inputTokens: import_zod.z.number().optional(),
  outputTokens: import_zod.z.number().optional(),
  totalTokens: import_zod.z.number().optional(),
  inputCharacters: import_zod.z.number().optional(),
  outputCharacters: import_zod.z.number().optional(),
  inputImages: import_zod.z.number().optional(),
  outputImages: import_zod.z.number().optional(),
  custom: import_zod.z.record(import_zod.z.number()).optional()
});
const CandidateSchema = import_zod.z.object({
  index: import_zod.z.number(),
  message: MessageSchema,
  usage: GenerationUsageSchema.optional(),
  finishReason: import_zod.z.enum(["stop", "length", "blocked", "other", "unknown"]),
  finishMessage: import_zod.z.string().optional(),
  custom: import_zod.z.unknown()
});
const CandidateErrorSchema = import_zod.z.object({
  index: import_zod.z.number(),
  code: import_zod.z.enum(["blocked", "other", "unknown"]),
  message: import_zod.z.string().optional()
});
const GenerateResponseSchema = import_zod.z.object({
  candidates: import_zod.z.array(CandidateSchema),
  latencyMs: import_zod.z.number().optional(),
  usage: GenerationUsageSchema.optional(),
  custom: import_zod.z.unknown(),
  request: GenerateRequestSchema.optional()
});
const GenerateResponseChunkSchema = import_zod.z.object({
  /** The index of the candidate this chunk belongs to. */
  index: import_zod.z.number(),
  /** The chunk of content to stream right now. */
  content: import_zod.z.array(PartSchema),
  /** Model-specific extra information attached to this chunk. */
  custom: import_zod.z.unknown().optional()
});
function defineModel(options, runner) {
  var _a;
  const label = options.label || `${options.name} GenAI model`;
  const middleware = [
    ...options.use || [],
    (0, import_middleware.validateSupport)(options)
  ];
  if (!((_a = options == null ? void 0 : options.supports) == null ? void 0 : _a.context))
    middleware.push((0, import_middleware.augmentWithContext)());
  middleware.push((0, import_middleware.conformOutput)());
  const act = (0, import_core.defineAction)(
    {
      actionType: "model",
      name: options.name,
      description: label,
      inputSchema: GenerateRequestSchema,
      outputSchema: GenerateResponseSchema,
      metadata: {
        model: {
          label,
          customOptions: options.configSchema ? (0, import_schema.toJsonSchema)({ schema: options.configSchema }) : void 0,
          versions: options.versions,
          supports: options.supports
        }
      },
      use: middleware
    },
    (input) => {
      const startTimeMs = import_node_perf_hooks.performance.now();
      return runner(input, (0, import_core.getStreamingCallback)()).then((response) => {
        const timedResponse = __spreadProps(__spreadValues({}, response), {
          latencyMs: import_node_perf_hooks.performance.now() - startTimeMs
        });
        telemetry.recordGenerateActionMetrics(options.name, input, {
          response: timedResponse
        });
        return timedResponse;
      }).catch((err) => {
        telemetry.recordGenerateActionMetrics(options.name, input, { err });
        throw err;
      });
    }
  );
  Object.assign(act, {
    __configSchema: options.configSchema || import_zod.z.unknown()
  });
  return act;
}
function modelRef(options) {
  return __spreadValues({}, options);
}
function getBasicUsageStats(input, candidates) {
  const responseCandidateParts = candidates.flatMap(
    (candidate) => candidate.message.content
  );
  const inputCounts = getPartCounts(input.flatMap((md) => md.content));
  const outputCounts = getPartCounts(
    candidates.flatMap((c) => c.message.content)
  );
  return {
    inputCharacters: inputCounts.characters,
    inputImages: inputCounts.images,
    outputCharacters: outputCounts.characters,
    outputImages: outputCounts.images
  };
}
function getPartCounts(parts) {
  return parts.reduce(
    (counts, part) => {
      var _a;
      return {
        characters: counts.characters + (((_a = part.text) == null ? void 0 : _a.length) || 0),
        images: counts.images + (part.media ? 1 : 0)
      };
    },
    { characters: 0, images: 0 }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CandidateErrorSchema,
  CandidateSchema,
  DataPartSchema,
  GenerateRequestSchema,
  GenerateResponseChunkSchema,
  GenerateResponseSchema,
  GenerationCommonConfigSchema,
  GenerationUsageSchema,
  MediaPartSchema,
  MessageSchema,
  ModelInfoSchema,
  PartSchema,
  RoleSchema,
  TextPartSchema,
  ToolDefinitionSchema,
  ToolRequestPartSchema,
  ToolResponsePartSchema,
  defineModel,
  getBasicUsageStats,
  modelRef
});
//# sourceMappingURL=model.js.map