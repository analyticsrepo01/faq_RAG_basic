{"version":3,"sources":["../src/generate.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Action,\n  config as genkitConfig,\n  GenkitError,\n  runWithStreamingCallback,\n  StreamingCallback,\n} from '@genkit-ai/core';\nimport { lookupAction } from '@genkit-ai/core/registry';\nimport { toJsonSchema, validateSchema } from '@genkit-ai/core/schema';\nimport { z } from 'zod';\nimport { DocumentData } from './document.js';\nimport { extractJson } from './extract.js';\nimport {\n  CandidateData,\n  GenerateRequest,\n  GenerateResponseChunkData,\n  GenerateResponseData,\n  GenerationCommonConfigSchema,\n  GenerationUsage,\n  MessageData,\n  ModelAction,\n  ModelArgument,\n  ModelReference,\n  Part,\n  Role,\n  ToolRequestPart,\n  ToolResponsePart,\n} from './model.js';\nimport * as telemetry from './telemetry.js';\nimport {\n  resolveTools,\n  ToolAction,\n  ToolArgument,\n  toToolDefinition,\n} from './tool.js';\n\n/**\n * Message represents a single role's contribution to a generation. Each message\n * can contain multiple parts (for example text and an image), and each generation\n * can contain multiple messages.\n */\nexport class Message<T = unknown> implements MessageData {\n  role: MessageData['role'];\n  content: Part[];\n\n  constructor(message: MessageData) {\n    this.role = message.role;\n    this.content = message.content;\n  }\n\n  /**\n   * If a message contains a `data` part, it is returned. Otherwise, the `output()`\n   * method extracts the first valid JSON object or array from the text contained in\n   * the message and returns it.\n   *\n   * @returns The structured output contained in the message.\n   */\n  output(): T | null {\n    return this.data() || extractJson<T>(this.text());\n  }\n\n  toolResponseParts(): ToolResponsePart[] {\n    const res = this.content.filter((part) => !!part.toolResponse);\n    return res as ToolResponsePart[];\n  }\n\n  /**\n   * Concatenates all `text` parts present in the message with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  text(): string {\n    return this.content.map((part) => part.text || '').join('');\n  }\n\n  /**\n   * Returns the first media part detected in the message. Useful for extracting\n   * (for example) an image from a generation expected to create one.\n   * @returns The first detected `media` part in the message.\n   */\n  media(): { url: string; contentType?: string } | null {\n    return this.content.find((part) => part.media)?.media || null;\n  }\n\n  /**\n   * Returns the first detected `data` part of a message.\n   * @returns The first `data` part detected in the message (if any).\n   */\n  data(): T | null {\n    return this.content.find((part) => part.data)?.data as T | null;\n  }\n\n  /**\n   * Returns all tool request found in this message.\n   * @returns Array of all tool request found in this message.\n   */\n  toolRequests(): ToolRequestPart[] {\n    return this.content.filter(\n      (part) => !!part.toolRequest\n    ) as ToolRequestPart[];\n  }\n\n  /**\n   * Converts the Message to a plain JS object.\n   * @returns Plain JS object representing the data contained in the message.\n   */\n  toJSON(): MessageData {\n    return {\n      role: this.role,\n      content: [...this.content],\n    };\n  }\n}\n\n/**\n * Candidate represents one of several possible generated responses from a generation\n * request. A candidate contains a single generated message along with additional\n * metadata about its generation. A generation request can create multiple candidates.\n */\nexport class Candidate<O = unknown> implements CandidateData {\n  /** The message this candidate generated. */\n  message: Message<O>;\n  /** The positional index of this candidate in the generation response. */\n  index: number;\n  /** Usage information about this candidate. */\n  usage: GenerationUsage;\n  /** The reason generation stopped for this candidate. */\n  finishReason: CandidateData['finishReason'];\n  /** Additional information about why the candidate stopped generating, if any. */\n  finishMessage?: string;\n  /** Additional provider-specific information about this candidate. */\n  custom: unknown;\n  /** The request that led to the generation of this candidate. */\n  request?: GenerateRequest;\n\n  constructor(candidate: CandidateData, request?: GenerateRequest) {\n    this.message = new Message(candidate.message);\n    this.index = candidate.index;\n    this.usage = candidate.usage || {};\n    this.finishReason = candidate.finishReason;\n    this.finishMessage = candidate.finishMessage || '';\n    this.custom = candidate.custom;\n    this.request = request;\n  }\n\n  /**\n   * If a candidate's message contains a `data` part, it is returned. Otherwise, the `output()`\n   * method extracts the first valid JSON object or array from the text contained in\n   * the candidate's message and returns it.\n   *\n   * @returns The structured output contained in the candidate.\n   */\n  output(): O | null {\n    return this.message.output();\n  }\n\n  /**\n   * Concatenates all `text` parts present in the candidate's message with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  text(): string {\n    return this.message.text();\n  }\n\n  /**\n   * Returns the first detected media part in the candidate's message. Useful for extracting\n   * (for example) an image from a generation expected to create one.\n   * @returns The first detected `media` part in the candidate.\n   */\n  media(): { url: string; contentType?: string } | null {\n    return this.message.media();\n  }\n\n  /**\n   * Returns the first detected `data` part of a candidate's message.\n   * @returns The first `data` part detected in the candidate (if any).\n   */\n  data(): O | null {\n    return this.message.data();\n  }\n\n  /**\n   * Returns all tool request found in this candidate.\n   * @returns Array of all tool request found in this candidate.\n   */\n  toolRequests(): ToolRequestPart[] {\n    return this.message.toolRequests();\n  }\n\n  /**\n   * Determine whether this candidate has output that conforms to a provided schema.\n   *\n   * @param request A request containing output schema to validate against. If not provided, uses request embedded in candidate.\n   * @returns True if output matches request schema or if no request schema is provided.\n   */\n  hasValidOutput(request?: GenerateRequest): boolean {\n    const o = this.output();\n    if (!request && !this.request) {\n      return true;\n    }\n    const { valid } = validateSchema(o, {\n      jsonSchema: request?.output?.schema || this.request?.output?.schema,\n    });\n    return valid;\n  }\n\n  /**\n   * Appends the message generated by this candidate to the messages already\n   * present in the generation request. The result of this method can be safely\n   * serialized to JSON for persistence in a database.\n   * @returns A serializable list of messages compatible with `generate({history})`.\n   */\n  toHistory(): MessageData[] {\n    if (!this.request)\n      throw new Error(\n        \"Can't construct history for candidate without request data.\"\n      );\n    return [...this.request?.messages, this.message.toJSON()];\n  }\n\n  /**\n   * Converts the Candidate to a plain JS object.\n   * @returns Plain JS object representing the data contained in the candidate.\n   */\n  toJSON(): CandidateData {\n    return {\n      message: this.message.toJSON(),\n      index: this.index,\n      usage: this.usage,\n      finishReason: this.finishReason,\n      finishMessage: this.finishMessage,\n      custom:\n        (!!this.custom && (this.custom as { toJSON?: () => any }).toJSON?.()) ||\n        this.custom,\n    };\n  }\n}\n\n/**\n * GenerateResponse is the result from a `generate()` call and contains one or\n * more generated candidate messages.\n */\nexport class GenerateResponse<O = unknown> implements GenerateResponseData {\n  /** The potential generated messages. */\n  candidates: Candidate<O>[];\n  /** Usage information. */\n  usage: GenerationUsage;\n  /** Provider-specific response data. */\n  custom: unknown;\n  /** The request that generated this response. */\n  request?: GenerateRequest;\n\n  /**\n   * If the selected candidate's message contains a `data` part, it is returned. Otherwise,\n   * the `output()` method extracts the first valid JSON object or array from the text\n   * contained in the selected candidate's message and returns it.\n   *\n   * @param index The candidate index from which to extract output. If not provided, finds first candidate that conforms to output schema.\n   * @returns The structured output contained in the selected candidate.\n   */\n  output(index?: number): O | null {\n    if (index === undefined) {\n      const c = this.candidates.find((c) => c.hasValidOutput(this.request));\n      return c?.output() || this.candidates[0]?.output();\n    }\n    return this.candidates[index!]?.output() || null;\n  }\n\n  /**\n   * Concatenates all `text` parts present in the candidate's message with no delimiter.\n   * @param index The candidate index from which to extract text, defaults to first candidate.\n   * @returns A string of all concatenated text parts.\n   */\n  text(index: number = 0): string {\n    return this.candidates[index]?.text() || '';\n  }\n\n  /**\n   * Returns the first detected media part in the selected candidate's message. Useful for\n   * extracting (for example) an image from a generation expected to create one.\n   * @param index The candidate index from which to extract media, defaults to first candidate.\n   * @returns The first detected `media` part in the candidate.\n   */\n  media(index: number = 0): { url: string; contentType?: string } | null {\n    return this.candidates[index]?.media() || null;\n  }\n\n  /**\n   * Returns the first detected `data` part of the selected candidate's message.\n   * @param index The candidate index from which to extract data, defaults to first candidate.\n   * @returns The first `data` part detected in the candidate (if any).\n   */\n  data(index: number = 0): O | null {\n    return this.candidates[index]?.data() || null;\n  }\n\n  /**\n   * Returns all tool request found in the candidate.\n   * @param index The candidate index from which to extract tool requests, defaults to first candidate.\n   * @returns Array of all tool request found in the candidate.\n   */\n  toolRequests(index: number = 0): ToolRequestPart[] {\n    return this.candidates[index].toolRequests();\n  }\n\n  /**\n   * Appends the message generated by the selected candidate to the messages already\n   * present in the generation request. The result of this method can be safely\n   * serialized to JSON for persistence in a database.\n   * @param index The candidate index to utilize during conversion, defaults to first candidate.\n   * @returns A serializable list of messages compatible with `generate({history})`.\n   */\n  toHistory(index: number = 0): MessageData[] {\n    return this.candidates[index].toHistory();\n  }\n\n  constructor(response: GenerateResponseData, request?: GenerateRequest) {\n    this.candidates = (response.candidates || []).map(\n      (candidate) => new Candidate(candidate, request)\n    );\n    this.usage = response.usage || {};\n    this.custom = response.custom || {};\n    this.request = request;\n  }\n\n  toJSON(): GenerateResponseData {\n    return {\n      candidates: this.candidates.map((candidate) => candidate.toJSON()),\n      usage: this.usage,\n      custom: (this.custom as { toJSON?: () => any }).toJSON?.() || this.custom,\n      request: this.request,\n    };\n  }\n}\n\nexport class GenerateResponseChunk<T = unknown>\n  implements GenerateResponseChunkData\n{\n  /** The index of the candidate this chunk corresponds to. */\n  index: number;\n  /** The content generated in this chunk. */\n  content: Part[];\n  /** Custom model-specific data for this chunk. */\n  custom?: unknown;\n\n  constructor(data: GenerateResponseChunkData) {\n    this.index = data.index;\n    this.content = data.content || [];\n    this.custom = data.custom;\n  }\n\n  /**\n   * Concatenates all `text` parts present in the chunk with no delimiter.\n   * @returns A string of all concatenated text parts.\n   */\n  text(): string {\n    return this.content.map((part) => part.text || '').join('');\n  }\n\n  /**\n   * Returns the first media part detected in the chunk. Useful for extracting\n   * (for example) an image from a generation expected to create one.\n   * @returns The first detected `media` part in the chunk.\n   */\n  media(): { url: string; contentType?: string } | null {\n    return this.content.find((part) => part.media)?.media || null;\n  }\n\n  /**\n   * Returns the first detected `data` part of a chunk.\n   * @returns The first `data` part detected in the chunk (if any).\n   */\n  data(): T | null {\n    return this.content.find((part) => part.data)?.data as T | null;\n  }\n\n  /**\n   * Returns all tool request found in this chunk.\n   * @returns Array of all tool request found in this chunk.\n   */\n  toolRequests(): ToolRequestPart[] {\n    return this.content.filter(\n      (part) => !!part.toolRequest\n    ) as ToolRequestPart[];\n  }\n\n  toJSON(): GenerateResponseChunkData {\n    return { index: this.index, content: this.content, custom: this.custom };\n  }\n}\n\nfunction getRoleFromPart(part: Part): Role {\n  if (part.toolRequest !== undefined) return 'model';\n  if (part.toolResponse !== undefined) return 'tool';\n  if (part.text !== undefined) return 'user';\n  if (part.media !== undefined) return 'user';\n  if (part.data !== undefined) return 'user';\n  throw new Error('No recognized fields in content');\n}\n\nfunction inferRoleFromParts(parts: Part[]): Role {\n  const uniqueRoles = new Set<Role>();\n  for (const part of parts) {\n    const role = getRoleFromPart(part);\n    uniqueRoles.add(role);\n    if (uniqueRoles.size > 1) {\n      throw new Error('Contents contain mixed roles');\n    }\n  }\n  return Array.from(uniqueRoles)[0];\n}\n\nexport async function toGenerateRequest(\n  options: GenerateOptions\n): Promise<GenerateRequest> {\n  const promptMessage: MessageData = { role: 'user', content: [] };\n  if (typeof options.prompt === 'string') {\n    promptMessage.content.push({ text: options.prompt });\n  } else if (Array.isArray(options.prompt)) {\n    promptMessage.role = inferRoleFromParts(options.prompt);\n    promptMessage.content.push(...options.prompt);\n  } else {\n    promptMessage.role = inferRoleFromParts([options.prompt]);\n    promptMessage.content.push(options.prompt);\n  }\n  const messages: MessageData[] = [...(options.history || []), promptMessage];\n  let tools: Action<any, any>[] | undefined;\n  if (options.tools) {\n    tools = await resolveTools(options.tools);\n  }\n\n  const out = {\n    messages,\n    candidates: options.candidates,\n    config: options.config,\n    context: options.context,\n    tools: tools?.map((tool) => toToolDefinition(tool)) || [],\n    output: {\n      format:\n        options.output?.format ||\n        (options.output?.schema || options.output?.jsonSchema\n          ? 'json'\n          : 'text'),\n      schema: toJsonSchema({\n        schema: options.output?.schema,\n        jsonSchema: options.output?.jsonSchema,\n      }),\n    },\n  };\n  if (!out.output.schema) delete out.output.schema;\n  return out;\n}\n\nexport interface GenerateOptions<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  /** A model name (e.g. `vertexai/gemini-1.0-pro`) or reference. */\n  model?: ModelArgument<CustomOptions>;\n  /** The prompt for which to generate a response. Can be a string for a simple text prompt or one or more parts for multi-modal prompts. */\n  prompt: string | Part | Part[];\n  /** Retrieved documents to be used as context for this generation. */\n  context?: DocumentData[];\n  /** Conversation history for multi-turn prompting when supported by the underlying model. */\n  history?: MessageData[];\n  /** List of registered tool names or actions to treat as a tool for this generation if supported by the underlying model. */\n  tools?: ToolArgument[];\n  /** Number of candidate messages to generate. */\n  candidates?: number;\n  /** Configuration for the generation request. */\n  config?: z.infer<CustomOptions>;\n  /** Configuration for the desired output of the request. Defaults to the model's default output if unspecified. */\n  output?: {\n    format?: 'text' | 'json' | 'media';\n    schema?: O;\n    jsonSchema?: any;\n  };\n  /** When true, return tool calls for manual processing instead of automatically resolving them. */\n  returnToolRequests?: boolean;\n  /** When provided, models supporting streaming will call the provided callback with chunks as generation progresses. */\n  streamingCallback?: StreamingCallback<GenerateResponseChunk>;\n}\n\nconst isValidCandidate = (\n  candidate: CandidateData,\n  tools: Action<any, any>[]\n): boolean => {\n  // Check if tool calls are vlaid\n  const toolCalls = candidate.message.content.filter(\n    (part) => !!part.toolRequest\n  );\n\n  // make sure every tool called exists and has valid input\n  return toolCalls.every((toolCall) => {\n    const tool = tools?.find(\n      (tool) => tool.__action.name === toolCall.toolRequest?.name\n    );\n    if (!tool) return false;\n    const { valid } = validateSchema(toolCall.toolRequest?.input, {\n      schema: tool.__action.inputSchema,\n      jsonSchema: tool.__action.inputJsonSchema,\n    });\n    return valid;\n  });\n};\n\nasync function resolveModel(options: GenerateOptions): Promise<ModelAction> {\n  let model = options.model;\n  if (!model) {\n    if (genkitConfig?.options?.defaultModel) {\n      model =\n        typeof genkitConfig.options.defaultModel.name === 'string'\n          ? genkitConfig.options.defaultModel.name\n          : genkitConfig.options.defaultModel.name.name;\n      if (\n        (!options.config || Object.keys(options.config).length === 0) &&\n        genkitConfig.options.defaultModel.config\n      ) {\n        // use configured global config\n        options.config = genkitConfig.options.defaultModel.config;\n      }\n    } else {\n      throw new Error('Unable to resolve model.');\n    }\n  }\n  if (typeof model === 'string') {\n    return (await lookupAction(`/model/${model}`)) as ModelAction;\n  } else if (model.hasOwnProperty('info')) {\n    const ref = model as ModelReference<any>;\n    return (await lookupAction(`/model/${ref.name}`)) as ModelAction;\n  } else {\n    return model as ModelAction;\n  }\n}\n\nexport class NoValidCandidatesError extends GenkitError {\n  detail: {\n    response: GenerateResponse;\n    [otherDetails: string]: any;\n  };\n\n  constructor({\n    message,\n    response,\n    detail,\n  }: {\n    message: string;\n    response: GenerateResponse;\n    detail?: Record<string, any>;\n  }) {\n    super({\n      status: 'FAILED_PRECONDITION',\n      message,\n      detail,\n    });\n    this.detail = { response, ...detail };\n  }\n}\n\n/**\n * Generate calls a generative model based on the provided prompt and configuration. If\n * `history` is provided, the generation will include a conversation history in its\n * request. If `tools` are provided, the generate method will automatically resolve\n * tool calls returned from the model unless `returnToolRequests` is set to `true`.\n *\n * See `GenerateOptions` for detailed information about available options.\n *\n * @param options The options for this generation request.\n * @returns The generated response based on the provided parameters.\n */\nexport async function generate<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema,\n>(\n  options:\n    | GenerateOptions<O, CustomOptions>\n    | PromiseLike<GenerateOptions<O, CustomOptions>>\n): Promise<GenerateResponse<z.infer<O>>> {\n  const resolvedOptions: GenerateOptions<O, CustomOptions> =\n    await Promise.resolve(options);\n  const model = await resolveModel(resolvedOptions);\n  if (!model) {\n    throw new Error(`Model ${JSON.stringify(resolvedOptions.model)} not found`);\n  }\n\n  let tools: ToolAction[] | undefined;\n  if (resolvedOptions.tools?.length) {\n    if (!model.__action.metadata?.model.supports?.tools) {\n      throw new Error(\n        `Model ${JSON.stringify(resolvedOptions.model)} does not support tools, but some tools were supplied to generate(). Please call generate() without tools if you would like to use this model.`\n      );\n    }\n    tools = await resolveTools(resolvedOptions.tools);\n  }\n\n  const request = await toGenerateRequest(resolvedOptions);\n  telemetry.recordGenerateActionInputLogs(\n    model.__action.name,\n    resolvedOptions,\n    request\n  );\n  const response = await runWithStreamingCallback(\n    resolvedOptions.streamingCallback\n      ? (chunk: GenerateResponseChunkData) =>\n          resolvedOptions.streamingCallback!(new GenerateResponseChunk(chunk))\n      : undefined,\n    async () => new GenerateResponse<z.infer<O>>(await model(request), request)\n  );\n\n  // throw NoValidCandidates if all candidates are blocked or\n  if (\n    !response.candidates.some((c) =>\n      ['stop', 'length'].includes(c.finishReason)\n    )\n  ) {\n    throw new NoValidCandidatesError({\n      message: `All candidates returned finishReason issues: ${JSON.stringify(response.candidates.map((c) => c.finishReason))}`,\n      response,\n    });\n  }\n\n  if (resolvedOptions.output?.schema || resolvedOptions.output?.jsonSchema) {\n    // find a candidate with valid output schema\n    const candidateValidations = response.candidates.map((c) => {\n      try {\n        return validateSchema(c.output(), {\n          jsonSchema: resolvedOptions.output?.jsonSchema,\n          schema: resolvedOptions.output?.schema,\n        });\n      } catch (e) {\n        return {\n          valid: false,\n          errors: [{ path: '', error: (e as Error).message }],\n        };\n      }\n    });\n    if (!candidateValidations.some((c) => c.valid)) {\n      throw new NoValidCandidatesError({\n        message:\n          'Generation resulted in no candidates matching provided output schema.',\n        response,\n        detail: {\n          candidateErrors: candidateValidations,\n        },\n      });\n    }\n  }\n\n  // Pick the first valid candidate.\n  let selected: Candidate<z.TypeOf<O>> | undefined;\n  for (const candidate of response.candidates) {\n    if (isValidCandidate(candidate, tools || [])) {\n      selected = candidate;\n      break;\n    }\n  }\n\n  if (!selected) {\n    throw new Error('No valid candidates found');\n  }\n\n  const toolCalls = selected.message.content.filter(\n    (part) => !!part.toolRequest\n  );\n  if (resolvedOptions.returnToolRequests || toolCalls.length === 0) {\n    telemetry.recordGenerateActionOutputLogs(\n      model.__action.name,\n      resolvedOptions,\n      response\n    );\n    return response;\n  }\n  const toolResponses: ToolResponsePart[] = await Promise.all(\n    toolCalls.map(async (part) => {\n      if (!part.toolRequest) {\n        throw Error(\n          'Tool request expected but not provided in tool request part'\n        );\n      }\n      const tool = tools?.find(\n        (tool) => tool.__action.name === part.toolRequest?.name\n      );\n      if (!tool) {\n        throw Error('Tool not found');\n      }\n      return {\n        toolResponse: {\n          name: part.toolRequest.name,\n          ref: part.toolRequest.ref,\n          output: await tool(part.toolRequest?.input),\n        },\n      };\n    })\n  );\n  resolvedOptions.history = request.messages;\n  resolvedOptions.history.push(selected.message);\n  resolvedOptions.prompt = toolResponses;\n  return await generate(resolvedOptions);\n}\n\nexport type GenerateStreamOptions<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema,\n> = Omit<GenerateOptions<O, CustomOptions>, 'streamingCallback'>;\n\nexport interface GenerateStreamResponse<O extends z.ZodTypeAny = z.ZodTypeAny> {\n  stream: () => AsyncIterable<GenerateResponseChunkData>;\n  response: () => Promise<GenerateResponse<O>>;\n}\n\nfunction createPromise<T>(): {\n  resolve: (result: T) => unknown;\n  reject: (err: unknown) => unknown;\n  promise: Promise<T>;\n} {\n  let resolve, reject;\n  let promise = new Promise<T>((res, rej) => ([resolve, reject] = [res, rej]));\n  return { resolve, reject, promise };\n}\n\nexport async function generateStream<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = typeof GenerationCommonConfigSchema,\n>(\n  options:\n    | GenerateOptions<O, CustomOptions>\n    | PromiseLike<GenerateOptions<O, CustomOptions>>\n): Promise<GenerateStreamResponse<O>> {\n  let firstChunkSent = false;\n  return new Promise<GenerateStreamResponse<O>>(\n    (initialResolve, initialReject) => {\n      const {\n        resolve: finalResolve,\n        reject: finalReject,\n        promise: finalPromise,\n      } = createPromise<GenerateResponse<O>>();\n\n      let provideNextChunk, nextChunk;\n      ({ resolve: provideNextChunk, promise: nextChunk } =\n        createPromise<GenerateResponseChunkData | null>());\n      async function* chunkStream(): AsyncIterable<GenerateResponseChunkData> {\n        while (true) {\n          const next = await nextChunk;\n          if (!next) break;\n          yield next;\n        }\n      }\n\n      try {\n        generate<O, CustomOptions>({\n          ...options,\n          streamingCallback: (chunk) => {\n            firstChunkSent = true;\n            provideNextChunk(chunk);\n            ({ resolve: provideNextChunk, promise: nextChunk } =\n              createPromise<GenerateResponseChunkData | null>());\n          },\n        }).then((result) => {\n          provideNextChunk(null);\n          finalResolve(result);\n        });\n      } catch (e) {\n        if (!firstChunkSent) {\n          initialReject(e);\n          return;\n        }\n        provideNextChunk(null);\n        finalReject(e);\n      }\n\n      initialResolve({\n        response: () => finalPromise,\n        stream: chunkStream,\n      });\n    }\n  );\n}\n"],"mappings":"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","names":["c","tool","_a","genkitConfig","_b"]}