import {
  __spreadProps,
  __spreadValues
} from "./chunk-7OAPEGJQ.mjs";
import { GENKIT_VERSION } from "@genkit-ai/core";
import { logger } from "@genkit-ai/core/logging";
import {
  internalMetricNamespaceWrap,
  MetricCounter,
  MetricHistogram
} from "@genkit-ai/core/metrics";
import { spanMetadataAls } from "@genkit-ai/core/tracing";
import { ValueType } from "@opentelemetry/api";
import { createHash } from "crypto";
const MAX_LOG_CONTENT_CHARS = 128e3;
const _N = internalMetricNamespaceWrap.bind(null, "ai");
const generateActionCounter = new MetricCounter(_N("generate/requests"), {
  description: "Counts calls to genkit generate actions.",
  valueType: ValueType.INT
});
const generateActionLatencies = new MetricHistogram(_N("generate/latency"), {
  description: "Latencies when interacting with a Genkit model.",
  valueType: ValueType.DOUBLE,
  unit: "ms"
});
const generateActionInputCharacters = new MetricCounter(
  _N("generate/input/characters"),
  {
    description: "Counts input characters to any Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionInputTokens = new MetricCounter(
  _N("generate/input/tokens"),
  {
    description: "Counts input tokens to a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionInputImages = new MetricCounter(
  _N("generate/input/images"),
  {
    description: "Counts input images to a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionOutputCharacters = new MetricCounter(
  _N("generate/output/characters"),
  {
    description: "Counts output characters from a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionOutputTokens = new MetricCounter(
  _N("generate/output/tokens"),
  {
    description: "Counts output tokens from a Genkit model.",
    valueType: ValueType.INT
  }
);
const generateActionOutputImages = new MetricCounter(
  _N("generate/output/images"),
  {
    description: "Count output images from a Genkit model.",
    valueType: ValueType.INT
  }
);
function recordGenerateActionMetrics(modelName, input, opts) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u;
  doRecordGenerateActionMetrics(modelName, {
    temperature: (_a = input.config) == null ? void 0 : _a.temperature,
    topK: (_b = input.config) == null ? void 0 : _b.topK,
    topP: (_c = input.config) == null ? void 0 : _c.topP,
    maxOutputTokens: (_d = input.config) == null ? void 0 : _d.maxOutputTokens,
    path: (_f = (_e = spanMetadataAls) == null ? void 0 : _e.getStore()) == null ? void 0 : _f.path,
    inputTokens: (_h = (_g = opts.response) == null ? void 0 : _g.usage) == null ? void 0 : _h.inputTokens,
    outputTokens: (_j = (_i = opts.response) == null ? void 0 : _i.usage) == null ? void 0 : _j.outputTokens,
    totalTokens: (_l = (_k = opts.response) == null ? void 0 : _k.usage) == null ? void 0 : _l.totalTokens,
    inputCharacters: (_n = (_m = opts.response) == null ? void 0 : _m.usage) == null ? void 0 : _n.inputCharacters,
    outputCharacters: (_p = (_o = opts.response) == null ? void 0 : _o.usage) == null ? void 0 : _p.outputCharacters,
    inputImages: (_r = (_q = opts.response) == null ? void 0 : _q.usage) == null ? void 0 : _r.inputImages,
    outputImages: (_t = (_s = opts.response) == null ? void 0 : _s.usage) == null ? void 0 : _t.outputImages,
    latencyMs: (_u = opts.response) == null ? void 0 : _u.latencyMs,
    err: opts.err,
    source: "ts",
    sourceVersion: GENKIT_VERSION
  });
}
function recordGenerateActionInputLogs(model, options, input) {
  var _a, _b, _c, _d, _e, _f, _g;
  const path = (_b = (_a = spanMetadataAls) == null ? void 0 : _a.getStore()) == null ? void 0 : _b.path;
  const sharedMetadata = { model, path };
  logger.logStructured(`Config[${path}, ${model}]`, __spreadProps(__spreadValues({}, sharedMetadata), {
    temperature: (_c = options.config) == null ? void 0 : _c.temperature,
    topK: (_d = options.config) == null ? void 0 : _d.topK,
    topP: (_e = options.config) == null ? void 0 : _e.topP,
    maxOutputTokens: (_f = options.config) == null ? void 0 : _f.maxOutputTokens,
    stopSequences: (_g = options.config) == null ? void 0 : _g.stopSequences,
    source: "ts",
    sourceVersion: GENKIT_VERSION
  }));
  const messages = input.messages.length;
  input.messages.forEach((msg, msgIdx) => {
    const parts = msg.content.length;
    msg.content.forEach((part, partIdx) => {
      const partCounts = toPartCounts(partIdx, parts, msgIdx, messages);
      logger.logStructured(`Input[${path}, ${model}] ${partCounts}`, __spreadProps(__spreadValues({}, sharedMetadata), {
        content: toPartLogContent(part),
        partIndex: partIdx,
        totalParts: parts,
        messageIndex: msgIdx,
        totalMessages: messages
      }));
    });
  });
}
function recordGenerateActionOutputLogs(model, options, output) {
  var _a, _b;
  const path = (_b = (_a = spanMetadataAls) == null ? void 0 : _a.getStore()) == null ? void 0 : _b.path;
  const sharedMetadata = { model, path };
  const candidates = output.candidates.length;
  output.candidates.forEach((cand, candIdx) => {
    const parts = cand.message.content.length;
    cand.message.content.forEach((part, partIdx) => {
      const partCounts = toPartCounts(partIdx, parts, candIdx, candidates);
      const initial = cand.finishMessage ? { finishMessage: toPartLogText(cand.finishMessage) } : {};
      logger.logStructured(`Output[${path}, ${model}] ${partCounts}`, __spreadProps(__spreadValues(__spreadValues({}, initial), sharedMetadata), {
        content: toPartLogContent(part),
        partIndex: partIdx,
        totalParts: parts,
        candidateIndex: candIdx,
        totalCandidates: candidates,
        messageIndex: cand.index,
        finishReason: cand.finishReason
      }));
    });
  });
}
function toPartCounts(partOrdinal, parts, msgOrdinal, messages) {
  if (parts > 1 && messages > 1) {
    return `(part ${xOfY(partOrdinal, parts)} in message ${xOfY(
      msgOrdinal,
      messages
    )})`;
  }
  if (parts > 1) {
    return `(part ${xOfY(partOrdinal, parts)})`;
  }
  if (messages > 1) {
    return `(message ${xOfY(msgOrdinal, messages)})`;
  }
  return "";
}
function xOfY(x, y) {
  return `${x} of ${y}`;
}
function toPartLogContent(part) {
  if (part.text) {
    return toPartLogText(part.text);
  }
  if (part.media) {
    return toPartLogMedia(part);
  }
  if (part.toolRequest) {
    return toPartLogToolRequest(part);
  }
  if (part.toolResponse) {
    return toPartLogToolResponse(part);
  }
  return "<unknown format>";
}
function toPartLogText(text) {
  return text.substring(0, MAX_LOG_CONTENT_CHARS);
}
function toPartLogMedia(part) {
  if (part.media.url.startsWith("data:")) {
    const splitIdx = part.media.url.indexOf("base64,");
    if (splitIdx < 0) {
      return "<unknown media format>";
    }
    const prefix = part.media.url.substring(0, splitIdx + 7);
    const hashedContent = createHash("sha256").update(part.media.url.substring(splitIdx + 7)).digest("hex");
    return `${prefix}<sha256(${hashedContent})>`;
  }
  return toPartLogText(part.media.url);
}
function toPartLogToolRequest(part) {
  const inputText = typeof part.toolRequest.input === "string" ? part.toolRequest.input : JSON.stringify(part.toolRequest.input);
  return toPartLogText(
    `Tool request: ${part.toolRequest.name}, ref: ${part.toolRequest.ref}, input: ${inputText}`
  );
}
function toPartLogToolResponse(part) {
  const outputText = typeof part.toolResponse.output === "string" ? part.toolResponse.output : JSON.stringify(part.toolResponse.output);
  return toPartLogText(
    `Tool response: ${part.toolResponse.name}, ref: ${part.toolResponse.ref}, output: ${outputText}`
  );
}
function doRecordGenerateActionMetrics(modelName, dimensions) {
  var _a, _b;
  const shared = {
    modelName,
    path: dimensions.path,
    temperature: dimensions.temperature,
    topK: dimensions.topK,
    topP: dimensions.topP,
    source: dimensions.source,
    sourceVersion: dimensions.sourceVersion
  };
  generateActionCounter.add(1, __spreadValues({
    maxOutputTokens: dimensions.maxOutputTokens,
    errorCode: (_a = dimensions.err) == null ? void 0 : _a.code,
    errorMessage: (_b = dimensions.err) == null ? void 0 : _b.message
  }, shared));
  generateActionLatencies.record(dimensions.latencyMs, shared);
  generateActionInputTokens.add(dimensions.inputTokens, shared);
  generateActionInputCharacters.add(dimensions.inputCharacters, shared);
  generateActionInputImages.add(dimensions.inputImages, shared);
  generateActionOutputTokens.add(dimensions.outputTokens, shared);
  generateActionOutputCharacters.add(dimensions.outputCharacters, shared);
  generateActionOutputImages.add(dimensions.outputImages, shared);
}
export {
  recordGenerateActionInputLogs,
  recordGenerateActionMetrics,
  recordGenerateActionOutputLogs
};
//# sourceMappingURL=telemetry.mjs.map