{"version":3,"sources":["../src/tool.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Action, defineAction, JSONSchema7 } from '@genkit-ai/core';\nimport { lookupAction } from '@genkit-ai/core/registry';\nimport { toJsonSchema } from '@genkit-ai/core/schema';\nimport { setCustomMetadataAttributes } from '@genkit-ai/core/tracing';\nimport z from 'zod';\nimport { ToolDefinition } from './model.js';\n\nexport type ToolAction<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n> = Action<I, O> & {\n  __action: {\n    metadata: {\n      type: 'tool';\n    };\n  };\n};\n\nexport type ToolArgument<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n> = string | ToolAction<I, O> | Action<I, O> | ToolDefinition;\n\nexport function asTool<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(\n  action: Action<I, O>\n): ToolAction<I, O> {\n  if (action.__action?.metadata?.type === 'tool') {\n    return action as ToolAction<I, O>;\n  }\n\n  const fn = ((input) => {\n    setCustomMetadataAttributes({ subtype: 'tool' });\n    return action(input);\n  }) as ToolAction<I, O>;\n  fn.__action = {\n    ...action.__action,\n    metadata: { ...action.__action.metadata, type: 'tool' },\n  };\n  return fn;\n}\n\nexport async function resolveTools<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  CustomOptions extends z.ZodTypeAny = z.ZodTypeAny,\n>(tools: ToolArgument[] = []): Promise<ToolAction[]> {\n  return await Promise.all(\n    tools.map(async (ref): Promise<ToolAction> => {\n      if (typeof ref === 'string') {\n        const tool = await lookupAction(`/tool/${ref}`);\n        if (!tool) {\n          throw new Error(`Tool ${ref} not found`);\n        }\n        return tool as ToolAction;\n      } else if ((ref as Action).__action) {\n        return asTool(ref as Action);\n      } else if (ref.name) {\n        const tool = await lookupAction(`/tool/${ref.name}`);\n        if (!tool) {\n          throw new Error(`Tool ${ref} not found`);\n        }\n      }\n      throw new Error('Tools must be strings, tool definitions, or actions.');\n    })\n  );\n}\n\nexport function toToolDefinition(\n  tool: Action<z.ZodTypeAny, z.ZodTypeAny>\n): ToolDefinition {\n  return {\n    name: tool.__action.name,\n    description: tool.__action.description || '',\n    outputSchema: toJsonSchema({\n      schema: tool.__action.outputSchema,\n      jsonSchema: tool.__action.outputJsonSchema,\n    })!,\n    inputSchema: toJsonSchema({\n      schema: tool.__action.inputSchema,\n      jsonSchema: tool.__action.inputJsonSchema,\n    })!,\n  };\n}\n\nexport function defineTool<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(\n  {\n    name,\n    description,\n    inputSchema,\n    inputJsonSchema,\n    outputSchema,\n    outputJsonSchema,\n    metadata,\n  }: {\n    name: string;\n    description: string;\n    inputSchema?: I;\n    inputJsonSchema?: JSONSchema7;\n    outputSchema?: O;\n    outputJsonSchema?: JSONSchema7;\n    metadata?: Record<string, any>;\n  },\n  fn: (input: z.infer<I>) => Promise<z.infer<O>>\n): ToolAction<I, O> {\n  const a = defineAction(\n    {\n      actionType: 'tool',\n      name,\n      description,\n      inputSchema,\n      inputJsonSchema,\n      outputSchema,\n      outputJsonSchema,\n      metadata: { ...(metadata || {}), type: 'tool' },\n    },\n    (i) => fn(i)\n  );\n  return a as ToolAction<I, O>;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,kBAAkD;AAClD,sBAA6B;AAC7B,oBAA6B;AAC7B,qBAA4C;AAoBrC,SAAS,OACd,QACkB;AAzCpB;AA0CE,QAAI,kBAAO,aAAP,mBAAiB,aAAjB,mBAA2B,UAAS,QAAQ;AAC9C,WAAO;AAAA,EACT;AAEA,QAAM,KAAM,CAAC,UAAU;AACrB,oDAA4B,EAAE,SAAS,OAAO,CAAC;AAC/C,WAAO,OAAO,KAAK;AAAA,EACrB;AACA,KAAG,WAAW,iCACT,OAAO,WADE;AAAA,IAEZ,UAAU,iCAAK,OAAO,SAAS,WAArB,EAA+B,MAAM,OAAO;AAAA,EACxD;AACA,SAAO;AACT;AAEA,SAAsB,eAG+B;AAAA,6CAAnD,QAAwB,CAAC,GAA0B;AACnD,WAAO,MAAM,QAAQ;AAAA,MACnB,MAAM,IAAI,CAAO,QAA6B;AAC5C,YAAI,OAAO,QAAQ,UAAU;AAC3B,gBAAM,OAAO,UAAM,8BAAa,SAAS,GAAG,EAAE;AAC9C,cAAI,CAAC,MAAM;AACT,kBAAM,IAAI,MAAM,QAAQ,GAAG,YAAY;AAAA,UACzC;AACA,iBAAO;AAAA,QACT,WAAY,IAAe,UAAU;AACnC,iBAAO,OAAO,GAAa;AAAA,QAC7B,WAAW,IAAI,MAAM;AACnB,gBAAM,OAAO,UAAM,8BAAa,SAAS,IAAI,IAAI,EAAE;AACnD,cAAI,CAAC,MAAM;AACT,kBAAM,IAAI,MAAM,QAAQ,GAAG,YAAY;AAAA,UACzC;AAAA,QACF;AACA,cAAM,IAAI,MAAM,sDAAsD;AAAA,MACxE,EAAC;AAAA,IACH;AAAA,EACF;AAAA;AAEO,SAAS,iBACd,MACgB;AAChB,SAAO;AAAA,IACL,MAAM,KAAK,SAAS;AAAA,IACpB,aAAa,KAAK,SAAS,eAAe;AAAA,IAC1C,kBAAc,4BAAa;AAAA,MACzB,QAAQ,KAAK,SAAS;AAAA,MACtB,YAAY,KAAK,SAAS;AAAA,IAC5B,CAAC;AAAA,IACD,iBAAa,4BAAa;AAAA,MACxB,QAAQ,KAAK,SAAS;AAAA,MACtB,YAAY,KAAK,SAAS;AAAA,IAC5B,CAAC;AAAA,EACH;AACF;AAEO,SAAS,WACd;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GASA,IACkB;AAClB,QAAM,QAAI;AAAA,IACR;AAAA,MACE,YAAY;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,UAAU,iCAAM,YAAY,CAAC,IAAnB,EAAuB,MAAM,OAAO;AAAA,IAChD;AAAA,IACA,CAAC,MAAM,GAAG,CAAC;AAAA,EACb;AACA,SAAO;AACT;","names":[]}