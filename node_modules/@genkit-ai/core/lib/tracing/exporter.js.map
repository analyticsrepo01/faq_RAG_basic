{"version":3,"sources":["../../src/tracing/exporter.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime, SpanKind } from '@opentelemetry/api';\nimport {\n  ExportResult,\n  ExportResultCode,\n  hrTimeToMilliseconds,\n} from '@opentelemetry/core';\nimport { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base';\nimport { logger } from '../logging.js';\nimport { deleteUndefinedProps } from '../utils.js';\nimport { SpanData, TraceData, TraceStore } from './types.js';\n\n/**\n * Exports collected OpenTelemetetry spans to Firestore.\n */\nexport class TraceStoreExporter implements SpanExporter {\n  constructor(private traceStore: TraceStore) {}\n\n  /**\n   * Export spans.\n   * @param spans\n   * @param resultCallback\n   */\n  export(\n    spans: ReadableSpan[],\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    this._sendSpans(spans, resultCallback);\n  }\n\n  /**\n   * Shutdown the exporter.\n   */\n  shutdown(): Promise<void> {\n    this._sendSpans([]);\n    return this.forceFlush();\n  }\n\n  /**\n   * Converts span info into trace store format.\n   * @param span\n   */\n  private _exportInfo(span: ReadableSpan): SpanData {\n    const spanData: Partial<SpanData> = {\n      spanId: span.spanContext().spanId,\n      traceId: span.spanContext().traceId,\n      startTime: transformTime(span.startTime),\n      endTime: transformTime(span.endTime),\n      attributes: { ...span.attributes },\n      displayName: span.name,\n      links: span.links,\n      spanKind: SpanKind[span.kind],\n      parentSpanId: span.parentSpanId,\n      sameProcessAsParentSpan: { value: !span.spanContext().isRemote },\n      status: span.status,\n      timeEvents: {\n        timeEvent: span.events.map((e) => ({\n          time: transformTime(e.time),\n          annotation: {\n            attributes: e.attributes ?? {},\n            description: e.name,\n          },\n        })),\n      },\n    };\n    if (span.instrumentationLibrary !== undefined) {\n      spanData.instrumentationLibrary = {\n        name: span.instrumentationLibrary.name,\n      };\n      if (span.instrumentationLibrary.schemaUrl !== undefined) {\n        spanData.instrumentationLibrary.schemaUrl =\n          span.instrumentationLibrary.schemaUrl;\n      }\n      if (span.instrumentationLibrary.version !== undefined) {\n        spanData.instrumentationLibrary.version =\n          span.instrumentationLibrary.version;\n      }\n    }\n    deleteUndefinedProps(spanData);\n    return spanData as SpanData;\n  }\n\n  /**\n   * Exports any pending spans in exporter\n   */\n  forceFlush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  private async _sendSpans(\n    spans: ReadableSpan[],\n    done?: (result: ExportResult) => void\n  ): Promise<void> {\n    const traces = {} as Record<string, ReadableSpan[]>;\n    for (const span of spans) {\n      if (!traces[span.spanContext().traceId]) {\n        traces[span.spanContext().traceId] = [];\n      }\n      traces[span.spanContext().traceId].push(span);\n    }\n    let error = false;\n    for (const traceId of Object.keys(traces)) {\n      try {\n        await this.save(traceId, traces[traceId]);\n      } catch (e) {\n        error = true;\n        logger.error('Failed to save trace ${traceId}', e);\n      }\n      if (done) {\n        return done({\n          code: error ? ExportResultCode.FAILED : ExportResultCode.SUCCESS,\n        });\n      }\n    }\n  }\n\n  private async save(traceId, spans: ReadableSpan[]): Promise<void> {\n    // TODO: add interface for Firestore doc\n    const data = {\n      traceId,\n      spans: {},\n    } as TraceData;\n    for (const span of spans) {\n      const convertedSpan = this._exportInfo(span);\n      data.spans[convertedSpan.spanId] = convertedSpan;\n      if (!convertedSpan.parentSpanId) {\n        data.displayName = convertedSpan.displayName;\n        data.startTime = convertedSpan.startTime;\n        data.endTime = convertedSpan.endTime;\n      }\n    }\n    await this.traceStore.save(traceId, data);\n  }\n}\n\n// Converts an HrTime to milliseconds.\nfunction transformTime(time: HrTime) {\n  return hrTimeToMilliseconds(time);\n}\n"],"mappings":"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","names":[]}