{"version":3,"sources":["../src/plugin.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { z } from 'zod';\nimport { Action } from './action.js';\nimport { FlowStateStore } from './flowTypes.js';\nimport { LoggerConfig, TelemetryConfig } from './telemetryTypes.js';\nimport { TraceStore } from './tracing.js';\n\nexport interface Provider<T> {\n  id: string;\n  value: T;\n}\n\nexport interface PluginProvider {\n  name: string;\n  initializer: () =>\n    | InitializedPlugin\n    | void\n    | Promise<InitializedPlugin | void>;\n}\n\nexport interface InitializedPlugin {\n  models?: Action<z.ZodTypeAny, z.ZodTypeAny>[];\n  retrievers?: Action<z.ZodTypeAny, z.ZodTypeAny>[];\n  embedders?: Action<z.ZodTypeAny, z.ZodTypeAny>[];\n  indexers?: Action<z.ZodTypeAny, z.ZodTypeAny>[];\n  evaluators?: Action<z.ZodTypeAny, z.ZodTypeAny>[];\n  flowStateStore?: Provider<FlowStateStore> | Provider<FlowStateStore>[];\n  traceStore?: Provider<TraceStore> | Provider<TraceStore>[];\n  telemetry?: {\n    instrumentation?: Provider<TelemetryConfig>;\n    logger?: Provider<LoggerConfig>;\n  };\n}\n\ntype PluginInit = (\n  ...args: any[]\n) => InitializedPlugin | void | Promise<InitializedPlugin | void>;\n\nexport type Plugin<T extends any[]> = (...args: T) => PluginProvider;\n\n/**\n * Defines a Genkit plugin.\n */\nexport function genkitPlugin<T extends PluginInit>(\n  pluginName: string,\n  initFn: T\n): Plugin<Parameters<T>> {\n  return (...args: Parameters<T>) => ({\n    name: pluginName,\n    initializer: async () => {\n      const initializedPlugin = (await initFn(...args)) || {};\n      validatePluginActions(pluginName, initializedPlugin);\n      return initializedPlugin;\n    },\n  });\n}\n\nfunction validatePluginActions(pluginName: string, plugin?: InitializedPlugin) {\n  if (!plugin) {\n    return;\n  }\n\n  plugin.models?.forEach((model) => validateNaming(pluginName, model));\n  plugin.retrievers?.forEach((retriever) =>\n    validateNaming(pluginName, retriever)\n  );\n  plugin.embedders?.forEach((embedder) => validateNaming(pluginName, embedder));\n  plugin.indexers?.forEach((indexer) => validateNaming(pluginName, indexer));\n  plugin.evaluators?.forEach((evaluator) =>\n    validateNaming(pluginName, evaluator)\n  );\n}\n\nfunction validateNaming(\n  pluginName: string,\n  action: Action<z.ZodTypeAny, z.ZodTypeAny>\n) {\n  const nameParts = action.__action.name.split('/');\n  if (nameParts[0] !== pluginName) {\n    const err = `Plugin name ${pluginName} not found in action name ${action.__action.name}. Action names must follow the pattern {pluginName}/{actionName}`;\n    throw new Error(err);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AA0DO,SAAS,aACd,YACA,QACuB;AACvB,SAAO,IAAI,UAAyB;AAAA,IAClC,MAAM;AAAA,IACN,aAAa,MAAY;AACvB,YAAM,qBAAqB,MAAM,OAAO,GAAG,IAAI,MAAM,CAAC;AACtD,4BAAsB,YAAY,iBAAiB;AACnD,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAEA,SAAS,sBAAsB,YAAoB,QAA4B;AAxE/E;AAyEE,MAAI,CAAC,QAAQ;AACX;AAAA,EACF;AAEA,eAAO,WAAP,mBAAe,QAAQ,CAAC,UAAU,eAAe,YAAY,KAAK;AAClE,eAAO,eAAP,mBAAmB;AAAA,IAAQ,CAAC,cAC1B,eAAe,YAAY,SAAS;AAAA;AAEtC,eAAO,cAAP,mBAAkB,QAAQ,CAAC,aAAa,eAAe,YAAY,QAAQ;AAC3E,eAAO,aAAP,mBAAiB,QAAQ,CAAC,YAAY,eAAe,YAAY,OAAO;AACxE,eAAO,eAAP,mBAAmB;AAAA,IAAQ,CAAC,cAC1B,eAAe,YAAY,SAAS;AAAA;AAExC;AAEA,SAAS,eACP,YACA,QACA;AACA,QAAM,YAAY,OAAO,SAAS,KAAK,MAAM,GAAG;AAChD,MAAI,UAAU,CAAC,MAAM,YAAY;AAC/B,UAAM,MAAM,eAAe,UAAU,6BAA6B,OAAO,SAAS,IAAI;AACtF,UAAM,IAAI,MAAM,GAAG;AAAA,EACrB;AACF;","names":[]}