{"version":3,"sources":["../src/schema.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Ajv, { ErrorObject, JSONSchemaType } from 'ajv';\nimport addFormats from 'ajv-formats';\nimport { z } from 'zod';\nimport zodToJsonSchema from 'zod-to-json-schema';\nimport { GenkitError } from './error.js';\nconst ajv = new Ajv();\naddFormats(ajv);\n\nexport { z }; // provide a consistent zod to use throughout genkit\nexport type JSONSchema = JSONSchemaType<any> | any;\nconst jsonSchemas = new WeakMap<z.ZodTypeAny, JSONSchema>();\nconst validators = new WeakMap<JSONSchema, ReturnType<typeof ajv.compile>>();\n\nexport interface ProvidedSchema {\n  jsonSchema?: JSONSchema;\n  schema?: z.ZodTypeAny;\n}\n\nexport class ValidationError extends GenkitError {\n  constructor({\n    data,\n    errors,\n    schema,\n  }: {\n    data: any;\n    errors: ValidationErrorDetail[];\n    schema: JSONSchema;\n  }) {\n    super({\n      status: 'INVALID_ARGUMENT',\n      message: `Schema validation failed. Parse Errors:\\n\\n${errors.map((e) => `- ${e.path}: ${e.message}`).join('\\n')}\\n\\nProvided data:\\n\\n${JSON.stringify(data, null, 2)}\\n\\nRequired JSON schema:\\n\\n${JSON.stringify(schema, null, 2)}`,\n      detail: { errors, schema },\n    });\n  }\n}\n\n/**\n * Convertes a Zod schema into a JSON schema, utilizing an in-memory cache for known objects.\n * @param options Provide a json schema and/or zod schema. JSON schema has priority.\n * @returns A JSON schema.\n */\nexport function toJsonSchema({\n  jsonSchema,\n  schema,\n}: ProvidedSchema): JSONSchema | undefined {\n  // if neither jsonSchema or schema is present return undefined\n  if (!jsonSchema && !schema) return null;\n  if (jsonSchema) return jsonSchema;\n  if (jsonSchemas.has(schema!)) return jsonSchemas.get(schema!)!;\n  const outSchema = zodToJsonSchema(schema!, {\n    $refStrategy: 'none',\n    removeAdditionalStrategy: 'strict',\n  });\n  jsonSchemas.set(schema!, outSchema as JSONSchema);\n  return outSchema as JSONSchema;\n}\n\nexport interface ValidationErrorDetail {\n  path: string;\n  message: string;\n}\n\nfunction toErrorDetail(error: ErrorObject): ValidationErrorDetail {\n  return {\n    path: error.instancePath.substring(1).replace(/\\//g, '.') || '(root)',\n    message: error.message!,\n  };\n}\n\nexport type ValidationResponse =\n  | { valid: true; errors: never }\n  | { valid: false; errors: ErrorObject[] };\n\nexport function validateSchema(\n  data: unknown,\n  options: ProvidedSchema\n): { valid: boolean; errors?: any[]; schema: JSONSchema } {\n  const toValidate = toJsonSchema(options);\n  if (!toValidate) {\n    return { valid: true, schema: toValidate };\n  }\n  const validator = validators.get(toValidate) || ajv.compile(toValidate);\n  const valid = validator(data) as boolean;\n  const errors = validator.errors?.map((e) => e);\n  return { valid, errors: errors?.map(toErrorDetail), schema: toValidate };\n}\n\nexport function parseSchema<T = unknown>(\n  data: unknown,\n  options: ProvidedSchema\n): T {\n  const { valid, errors, schema } = validateSchema(data, options);\n  if (!valid) throw new ValidationError({ data, errors: errors!, schema });\n  return data as T;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgBA,iBAAiD;AACjD,yBAAuB;AACvB,iBAAkB;AAClB,gCAA4B;AAC5B,mBAA4B;AAC5B,MAAM,MAAM,IAAI,WAAAA,QAAI;AAAA,IACpB,mBAAAC,SAAW,GAAG;AAId,MAAM,cAAc,oBAAI,QAAkC;AAC1D,MAAM,aAAa,oBAAI,QAAoD;AAOpE,MAAM,wBAAwB,yBAAY;AAAA,EAC/C,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIG;AACD,UAAM;AAAA,MACJ,QAAQ;AAAA,MACR,SAAS;AAAA;AAAA,EAA8C,OAAO,IAAI,CAAC,MAAM,KAAK,EAAE,IAAI,KAAK,EAAE,OAAO,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA;AAAA;AAAA,EAAyB,KAAK,UAAU,MAAM,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA,EAAgC,KAAK,UAAU,QAAQ,MAAM,CAAC,CAAC;AAAA,MACrO,QAAQ,EAAE,QAAQ,OAAO;AAAA,IAC3B,CAAC;AAAA,EACH;AACF;AAOO,SAAS,aAAa;AAAA,EAC3B;AAAA,EACA;AACF,GAA2C;AAEzC,MAAI,CAAC,cAAc,CAAC;AAAQ,WAAO;AACnC,MAAI;AAAY,WAAO;AACvB,MAAI,YAAY,IAAI,MAAO;AAAG,WAAO,YAAY,IAAI,MAAO;AAC5D,QAAM,gBAAY,0BAAAC,SAAgB,QAAS;AAAA,IACzC,cAAc;AAAA,IACd,0BAA0B;AAAA,EAC5B,CAAC;AACD,cAAY,IAAI,QAAS,SAAuB;AAChD,SAAO;AACT;AAOA,SAAS,cAAc,OAA2C;AAChE,SAAO;AAAA,IACL,MAAM,MAAM,aAAa,UAAU,CAAC,EAAE,QAAQ,OAAO,GAAG,KAAK;AAAA,IAC7D,SAAS,MAAM;AAAA,EACjB;AACF;AAMO,SAAS,eACd,MACA,SACwD;AA5F1D;AA6FE,QAAM,aAAa,aAAa,OAAO;AACvC,MAAI,CAAC,YAAY;AACf,WAAO,EAAE,OAAO,MAAM,QAAQ,WAAW;AAAA,EAC3C;AACA,QAAM,YAAY,WAAW,IAAI,UAAU,KAAK,IAAI,QAAQ,UAAU;AACtE,QAAM,QAAQ,UAAU,IAAI;AAC5B,QAAM,UAAS,eAAU,WAAV,mBAAkB,IAAI,CAAC,MAAM;AAC5C,SAAO,EAAE,OAAO,QAAQ,iCAAQ,IAAI,gBAAgB,QAAQ,WAAW;AACzE;AAEO,SAAS,YACd,MACA,SACG;AACH,QAAM,EAAE,OAAO,QAAQ,OAAO,IAAI,eAAe,MAAM,OAAO;AAC9D,MAAI,CAAC;AAAO,UAAM,IAAI,gBAAgB,EAAE,MAAM,QAAiB,OAAO,CAAC;AACvE,SAAO;AACT;","names":["Ajv","addFormats","zodToJsonSchema"]}