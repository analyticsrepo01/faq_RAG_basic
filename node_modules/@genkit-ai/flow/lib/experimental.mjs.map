{"version":3,"sources":["../src/experimental.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Action, Operation } from '@genkit-ai/core';\nimport { logger } from '@genkit-ai/core/logging';\nimport * as z from 'zod';\nimport { PollingConfig } from './context.js';\nimport {\n  FlowExecutionError,\n  FlowNotFoundError,\n  FlowStillRunningError,\n} from './errors.js';\nimport {\n  Flow,\n  FlowWrapper,\n  RunStepConfig,\n  StepsFunction,\n  defineFlow,\n} from './flow.js';\nimport { Invoker, Scheduler } from './types.js';\nimport { getActiveContext } from './utils.js';\n\n/**\n * Defines the durable flow.\n */\nexport function durableFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  config: {\n    name: string;\n    inputSchema?: I;\n    outputSchema?: O;\n    streamSchema?: S;\n    invoker?: Invoker<I, O, S>;\n    scheduler?: Scheduler<I, O, S>;\n  },\n  steps: StepsFunction<I, O, S>\n): Flow<I, O, S> {\n  return defineFlow(\n    {\n      name: config.name,\n      inputSchema: config.inputSchema,\n      outputSchema: config.outputSchema,\n      streamSchema: config.streamSchema,\n      invoker: config.invoker,\n      experimentalScheduler: config.scheduler,\n      experimentalDurable: true,\n    },\n    steps\n  );\n}\n\n/**\n * Schedules a flow run. This is always return an operation that's not completed (done=false).\n */\nexport async function scheduleFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  flow: Flow<I, O, S> | FlowWrapper<I, O, S>,\n  payload: z.infer<I>,\n  delaySeconds?: number\n): Promise<Operation> {\n  if (!(flow instanceof Flow)) {\n    flow = flow.flow;\n  }\n  const state = await flow.invoker(flow, {\n    schedule: {\n      input: flow.inputSchema ? flow.inputSchema.parse(payload) : payload,\n      delay: delaySeconds,\n    },\n  });\n  return state;\n}\n\n/**\n * Resumes an interrupted flow.\n */\nexport async function resumeFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  flow: Flow<I, O, S> | FlowWrapper<I, O, S>,\n  flowId: string,\n  payload: any\n): Promise<Operation> {\n  if (!(flow instanceof Flow)) {\n    flow = flow.flow;\n  }\n  return await flow.invoker(flow, {\n    resume: {\n      flowId,\n      payload,\n    },\n  });\n}\n\n/**\n * Returns an operation representing current state of the flow.\n */\nexport async function getFlowState<\n  I extends z.ZodTypeAny,\n  O extends z.ZodTypeAny,\n  S extends z.ZodTypeAny,\n>(\n  flow: Flow<I, O, S> | FlowWrapper<I, O, S>,\n  flowId: string\n): Promise<Operation> {\n  if (!(flow instanceof Flow)) {\n    flow = flow.flow;\n  }\n  if (!flow.stateStore) {\n    throw new Error('Flow state must be configured.');\n  }\n  const state = await (await flow.stateStore()).load(flowId);\n  if (!state) {\n    throw new FlowNotFoundError(`flow state ${flowId} not found`);\n  }\n  const op = {\n    ...state.operation,\n  } as Operation;\n  if (state.blockedOnStep) {\n    op.blockedOnStep = state.blockedOnStep;\n  }\n  return op;\n}\n/**\n * A flow steap that executes an action with provided input and memoizes the output.\n */\nexport function runAction<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(\n  action: Action<I, O>,\n  input: z.infer<I>,\n  actionConfig?: RunStepConfig\n): Promise<z.infer<O>> {\n  const config: RunStepConfig = {\n    ...actionConfig,\n    name: actionConfig?.name || action.__action.name,\n  };\n  return run(config, input, () => action(input));\n}\n\n/**\n * A local utility that waits for the flow execution to complete. If flow errored then a\n * {@link FlowExecutionError} will be thrown.\n */\nexport async function waitFlowToComplete<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  flow: Flow<I, O, S> | FlowWrapper<I, O, S>,\n  flowId: string\n): Promise<z.infer<O>> {\n  if (!(flow instanceof Flow)) {\n    flow = flow.flow;\n  }\n  let state: Operation | undefined = undefined;\n  try {\n    state = await getFlowState(flow, flowId);\n  } catch (e) {\n    logger.error(e);\n    // TODO: add timeout\n    if (!(e instanceof FlowNotFoundError)) {\n      throw e;\n    }\n  }\n  if (state && state?.done) {\n    return parseOutput(flowId, state);\n  } else {\n    await asyncSleep(1000);\n    return await waitFlowToComplete(flow, flowId);\n  }\n}\n\nfunction parseOutput<O extends z.ZodTypeAny>(\n  flowId: string,\n  state: Operation\n): z.infer<O> {\n  if (!state.done) {\n    throw new FlowStillRunningError(flowId);\n  }\n  if (state.result?.error) {\n    throw new FlowExecutionError(\n      flowId,\n      state.result.error,\n      state.result.stacktrace\n    );\n  }\n  return state.result?.response;\n}\n\nexport function run<T>(\n  experimentalConfig: RunStepConfig,\n  func: () => Promise<T>\n): Promise<T>;\nexport function run<T>(\n  experimentalConfig: RunStepConfig,\n  input: any | undefined,\n  func: () => Promise<T>\n): Promise<T>;\nexport function run<T>(name: string, func: () => Promise<T>): Promise<T>;\n\n/**\n * A flow steap that executes the provided function and memoizes the output.\n */\nexport function run<T>(\n  nameOrConfig: string | RunStepConfig,\n  funcOrInput: () => Promise<T>,\n  fn?: () => Promise<T>\n): Promise<T> {\n  let config: RunStepConfig;\n  if (typeof nameOrConfig === 'string') {\n    config = {\n      name: nameOrConfig,\n    };\n  } else {\n    config = nameOrConfig;\n  }\n  const func = arguments.length === 3 ? fn : funcOrInput;\n  const input = arguments.length === 3 ? funcOrInput : undefined;\n  if (!func) {\n    throw new Error('unable to resolve run function');\n  }\n  const ctx = getActiveContext();\n  if (!ctx) throw new Error('can only be run from a flow');\n  return ctx.run(config, input, func);\n}\n\n/**\n * Interrupts the flow execution until the flow is resumed with input defined by `responseSchema`.\n */\nexport function interrupt<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(\n  stepName: string,\n  responseSchema: I,\n  func?: (payload: z.infer<I>) => Promise<z.infer<O>>\n): Promise<z.infer<O>> {\n  const ctx = getActiveContext();\n  if (!ctx) throw new Error('interrupt can only be run from a flow');\n  return ctx.interrupt(\n    stepName,\n    func || ((input: z.infer<I>): z.infer<O> => input),\n    responseSchema\n  );\n}\n\n/**\n * Interrupts flow execution and resumes it when specified amount if time elapses.\n */\nexport function sleep(actionId: string, durationMs: number) {\n  const ctx = getActiveContext();\n  if (!ctx) throw new Error('sleep can only be run from a flow');\n  return ctx.sleep(actionId, durationMs);\n}\n\n/**\n * Interrupts the flow and periodically check for the flow ID to complete.\n */\nexport function waitFor(\n  stepName: string,\n  flow: Flow<z.ZodTypeAny, z.ZodTypeAny, z.ZodTypeAny>,\n  flowIds: string[],\n  pollingConfig?: PollingConfig\n): Promise<Operation[]> {\n  const ctx = getActiveContext();\n  if (!ctx) throw new Error('waitFor can only be run from a flow');\n  return ctx.waitFor({ flow, stepName, flowIds, pollingConfig });\n}\n\nexport async function asyncSleep(duration: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, duration);\n  });\n}\n"],"mappings":";;;;;AAiBA,SAAS,cAAc;AAGvB;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP;AAAA,EACE;AAAA,EAIA;AAAA,OACK;AAEP,SAAS,wBAAwB;AAK1B,SAAS,YAKd,QAQA,OACe;AACf,SAAO;AAAA,IACL;AAAA,MACE,MAAM,OAAO;AAAA,MACb,aAAa,OAAO;AAAA,MACpB,cAAc,OAAO;AAAA,MACrB,cAAc,OAAO;AAAA,MACrB,SAAS,OAAO;AAAA,MAChB,uBAAuB,OAAO;AAAA,MAC9B,qBAAqB;AAAA,IACvB;AAAA,IACA;AAAA,EACF;AACF;AAKA,SAAsB,aAKpB,MACA,SACA,cACoB;AAAA;AACpB,QAAI,EAAE,gBAAgB,OAAO;AAC3B,aAAO,KAAK;AAAA,IACd;AACA,UAAM,QAAQ,MAAM,KAAK,QAAQ,MAAM;AAAA,MACrC,UAAU;AAAA,QACR,OAAO,KAAK,cAAc,KAAK,YAAY,MAAM,OAAO,IAAI;AAAA,QAC5D,OAAO;AAAA,MACT;AAAA,IACF,CAAC;AACD,WAAO;AAAA,EACT;AAAA;AAKA,SAAsB,WAKpB,MACA,QACA,SACoB;AAAA;AACpB,QAAI,EAAE,gBAAgB,OAAO;AAC3B,aAAO,KAAK;AAAA,IACd;AACA,WAAO,MAAM,KAAK,QAAQ,MAAM;AAAA,MAC9B,QAAQ;AAAA,QACN;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAKA,SAAsB,aAKpB,MACA,QACoB;AAAA;AACpB,QAAI,EAAE,gBAAgB,OAAO;AAC3B,aAAO,KAAK;AAAA,IACd;AACA,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,gCAAgC;AAAA,IAClD;AACA,UAAM,QAAQ,OAAO,MAAM,KAAK,WAAW,GAAG,KAAK,MAAM;AACzD,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,kBAAkB,cAAc,MAAM,YAAY;AAAA,IAC9D;AACA,UAAM,KAAK,mBACN,MAAM;AAEX,QAAI,MAAM,eAAe;AACvB,SAAG,gBAAgB,MAAM;AAAA,IAC3B;AACA,WAAO;AAAA,EACT;AAAA;AAIO,SAAS,UACd,QACA,OACA,cACqB;AACrB,QAAM,SAAwB,iCACzB,eADyB;AAAA,IAE5B,OAAM,6CAAc,SAAQ,OAAO,SAAS;AAAA,EAC9C;AACA,SAAO,IAAI,QAAQ,OAAO,MAAM,OAAO,KAAK,CAAC;AAC/C;AAMA,SAAsB,mBAKpB,MACA,QACqB;AAAA;AACrB,QAAI,EAAE,gBAAgB,OAAO;AAC3B,aAAO,KAAK;AAAA,IACd;AACA,QAAI,QAA+B;AACnC,QAAI;AACF,cAAQ,MAAM,aAAa,MAAM,MAAM;AAAA,IACzC,SAAS,GAAG;AACV,aAAO,MAAM,CAAC;AAEd,UAAI,EAAE,aAAa,oBAAoB;AACrC,cAAM;AAAA,MACR;AAAA,IACF;AACA,QAAI,UAAS,+BAAO,OAAM;AACxB,aAAO,YAAY,QAAQ,KAAK;AAAA,IAClC,OAAO;AACL,YAAM,WAAW,GAAI;AACrB,aAAO,MAAM,mBAAmB,MAAM,MAAM;AAAA,IAC9C;AAAA,EACF;AAAA;AAEA,SAAS,YACP,QACA,OACY;AAlMd;AAmME,MAAI,CAAC,MAAM,MAAM;AACf,UAAM,IAAI,sBAAsB,MAAM;AAAA,EACxC;AACA,OAAI,WAAM,WAAN,mBAAc,OAAO;AACvB,UAAM,IAAI;AAAA,MACR;AAAA,MACA,MAAM,OAAO;AAAA,MACb,MAAM,OAAO;AAAA,IACf;AAAA,EACF;AACA,UAAO,WAAM,WAAN,mBAAc;AACvB;AAgBO,SAAS,IACd,cACA,aACA,IACY;AACZ,MAAI;AACJ,MAAI,OAAO,iBAAiB,UAAU;AACpC,aAAS;AAAA,MACP,MAAM;AAAA,IACR;AAAA,EACF,OAAO;AACL,aAAS;AAAA,EACX;AACA,QAAM,OAAO,UAAU,WAAW,IAAI,KAAK;AAC3C,QAAM,QAAQ,UAAU,WAAW,IAAI,cAAc;AACrD,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,gCAAgC;AAAA,EAClD;AACA,QAAM,MAAM,iBAAiB;AAC7B,MAAI,CAAC;AAAK,UAAM,IAAI,MAAM,6BAA6B;AACvD,SAAO,IAAI,IAAI,QAAQ,OAAO,IAAI;AACpC;AAKO,SAAS,UACd,UACA,gBACA,MACqB;AACrB,QAAM,MAAM,iBAAiB;AAC7B,MAAI,CAAC;AAAK,UAAM,IAAI,MAAM,uCAAuC;AACjE,SAAO,IAAI;AAAA,IACT;AAAA,IACA,SAAS,CAAC,UAAkC;AAAA,IAC5C;AAAA,EACF;AACF;AAKO,SAAS,MAAM,UAAkB,YAAoB;AAC1D,QAAM,MAAM,iBAAiB;AAC7B,MAAI,CAAC;AAAK,UAAM,IAAI,MAAM,mCAAmC;AAC7D,SAAO,IAAI,MAAM,UAAU,UAAU;AACvC;AAKO,SAAS,QACd,UACA,MACA,SACA,eACsB;AACtB,QAAM,MAAM,iBAAiB;AAC7B,MAAI,CAAC;AAAK,UAAM,IAAI,MAAM,qCAAqC;AAC/D,SAAO,IAAI,QAAQ,EAAE,MAAM,UAAU,SAAS,cAAc,CAAC;AAC/D;AAEA,SAAsB,WAAW,UAAkB;AAAA;AACjD,WAAO,IAAI,QAAQ,CAAC,YAAY;AAC9B,iBAAW,SAAS,QAAQ;AAAA,IAC9B,CAAC;AAAA,EACH;AAAA;","names":[]}