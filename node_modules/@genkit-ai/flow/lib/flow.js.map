{"version":3,"sources":["../src/flow.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Action,\n  FlowError,\n  FlowState,\n  FlowStateSchema,\n  FlowStateStore,\n  Operation,\n  StreamingCallback,\n  defineAction,\n  getStreamingCallback,\n  config as globalConfig,\n  isDevEnv,\n} from '@genkit-ai/core';\nimport { logger } from '@genkit-ai/core/logging';\nimport { toJsonSchema } from '@genkit-ai/core/schema';\nimport {\n  SPAN_TYPE_ATTR,\n  newTrace,\n  setCustomMetadataAttribute,\n  setCustomMetadataAttributes,\n} from '@genkit-ai/core/tracing';\nimport { SpanStatusCode } from '@opentelemetry/api';\nimport * as bodyParser from 'body-parser';\nimport { CorsOptions, default as cors } from 'cors';\nimport express from 'express';\nimport { performance } from 'node:perf_hooks';\nimport * as z from 'zod';\nimport { Context } from './context.js';\nimport {\n  FlowExecutionError,\n  FlowStillRunningError,\n  InterruptError,\n  getErrorMessage,\n  getErrorStack,\n} from './errors.js';\nimport * as telemetry from './telemetry.js';\nimport {\n  FlowActionInputSchema,\n  FlowInvokeEnvelopeMessage,\n  FlowInvokeEnvelopeMessageSchema,\n  Invoker,\n  RetryConfig,\n  Scheduler,\n} from './types.js';\nimport {\n  generateFlowId,\n  metadataPrefix,\n  runWithActiveContext,\n} from './utils.js';\n\nconst streamDelimiter = '\\n';\n\nconst CREATED_FLOWS = 'genkit__CREATED_FLOWS';\n\nfunction createdFlows(): Flow<any, any, any>[] {\n  if (global[CREATED_FLOWS] === undefined) {\n    global[CREATED_FLOWS] = [];\n  }\n  return global[CREATED_FLOWS];\n}\n\n/**\n * Step configuration for retries, etc.\n */\nexport interface RunStepConfig {\n  name: string;\n  retryConfig?: RetryConfig;\n}\n\n/**\n * Flow Auth policy. Consumes the authorization context of the flow and\n * performs checks before the flow runs. If this throws, the flow will not\n * be executed.\n */\nexport interface FlowAuthPolicy<I extends z.ZodTypeAny = z.ZodTypeAny> {\n  (auth: any | undefined, input: z.infer<I>): void | Promise<void>;\n}\n\n/**\n * For express-based flows, req.auth should contain the value to bepassed into\n * the flow context.\n */\nexport interface __RequestWithAuth extends express.Request {\n  auth?: unknown;\n}\n\n/**\n * Defines the flow.\n */\nexport function defineFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  config: {\n    name: string;\n    inputSchema?: I;\n    outputSchema?: O;\n    streamSchema?: S;\n    authPolicy?: FlowAuthPolicy<I>;\n    middleware?: express.RequestHandler[];\n    invoker?: Invoker<I, O, S>;\n    experimentalDurable?: boolean;\n    experimentalScheduler?: Scheduler<I, O, S>;\n  },\n  steps: StepsFunction<I, O, S>\n): Flow<I, O, S> {\n  const f = new Flow(\n    {\n      name: config.name,\n      inputSchema: config.inputSchema,\n      outputSchema: config.outputSchema,\n      streamSchema: config.streamSchema,\n      experimentalDurable: !!config.experimentalDurable,\n      stateStore: globalConfig\n        ? () => globalConfig.getFlowStateStore()\n        : undefined,\n      authPolicy: config.authPolicy,\n      middleware: config.middleware,\n      // We always use local dispatcher in dev mode or when one is not provided.\n      invoker: async (flow, msg, streamingCallback) => {\n        if (!isDevEnv() && config.invoker) {\n          return config.invoker(flow, msg, streamingCallback);\n        }\n        const state = await flow.runEnvelope(msg, streamingCallback);\n        return state.operation;\n      },\n      scheduler: async (flow, msg, delay = 0) => {\n        if (!config.experimentalDurable) {\n          throw new Error(\n            'This flow is not durable, cannot use scheduling features.'\n          );\n        }\n        if (!isDevEnv() && config.experimentalScheduler) {\n          return config.experimentalScheduler(flow, msg, delay);\n        }\n        setTimeout(() => flow.runEnvelope(msg), delay * 1000);\n      },\n    },\n    steps\n  );\n  createdFlows().push(f);\n  wrapAsAction(f);\n  return f;\n}\n\nexport interface FlowWrapper<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  flow: Flow<I, O, S>;\n}\n\nexport class Flow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  readonly name: string;\n  readonly inputSchema?: I;\n  readonly outputSchema?: O;\n  readonly streamSchema?: S;\n  readonly stateStore?: () => Promise<FlowStateStore>;\n  readonly invoker: Invoker<I, O, S>;\n  readonly scheduler: Scheduler<I, O, S>;\n  readonly experimentalDurable: boolean;\n  readonly authPolicy?: FlowAuthPolicy<I>;\n  readonly middleware?: express.RequestHandler[];\n\n  constructor(\n    config: {\n      name: string;\n      inputSchema?: I;\n      outputSchema?: O;\n      streamSchema?: S;\n      stateStore?: () => Promise<FlowStateStore>;\n      invoker: Invoker<I, O, S>;\n      scheduler: Scheduler<I, O, S>;\n      experimentalDurable: boolean;\n      authPolicy?: FlowAuthPolicy<I>;\n      middleware?: express.RequestHandler[];\n    },\n    private steps: StepsFunction<I, O, S>\n  ) {\n    this.name = config.name;\n    this.inputSchema = config.inputSchema;\n    this.outputSchema = config.outputSchema;\n    this.streamSchema = config.streamSchema;\n    this.stateStore = config.stateStore;\n    this.invoker = config.invoker;\n    this.scheduler = config.scheduler;\n    this.experimentalDurable = config.experimentalDurable;\n    this.authPolicy = config.authPolicy;\n    this.middleware = config.middleware;\n\n    // Durable flows can't use an auth policy; instead they should be invoked\n    // from a privileged context after ACL checks are performed.\n    if (this.authPolicy && this.experimentalDurable) {\n      throw new Error('Durable flows can not define auth policies.');\n    }\n  }\n\n  /**\n   * Executes the flow with the input directly.\n   *\n   * This will either be called by runEnvelope when starting durable flows,\n   * or it will be called directly when starting non-durable flows.\n   */\n  async runDirectly(\n    input: unknown,\n    opts: {\n      streamingCallback?: StreamingCallback<unknown>;\n      labels?: Record<string, string>;\n      auth?: unknown;\n    }\n  ): Promise<FlowState> {\n    const flowId = generateFlowId();\n    const state = createNewState(flowId, this.name, input);\n    const ctx = new Context(this, flowId, state, opts.auth);\n    try {\n      await this.executeSteps(\n        ctx,\n        this.steps,\n        'start',\n        opts.streamingCallback,\n        opts.labels\n      );\n    } finally {\n      if (isDevEnv() || this.experimentalDurable) {\n        await ctx.saveState();\n      }\n    }\n    return state;\n  }\n\n  /**\n   * Executes the flow with the input in the envelope format.\n   */\n  async runEnvelope(\n    req: FlowInvokeEnvelopeMessage,\n    streamingCallback?: StreamingCallback<any>,\n    auth?: unknown\n  ): Promise<FlowState> {\n    logger.debug(req, 'runEnvelope');\n    if (req.start) {\n      // First time, create new state.\n      return this.runDirectly(req.start.input, {\n        streamingCallback,\n        auth,\n        labels: req.start.labels,\n      });\n    }\n    if (req.schedule) {\n      if (!this.experimentalDurable) {\n        throw new Error('Cannot schedule a non-durable flow');\n      }\n      if (!this.stateStore) {\n        throw new Error(\n          'Flow state store for durable flows must be configured'\n        );\n      }\n      // First time, create new state.\n      const flowId = generateFlowId();\n      const state = createNewState(flowId, this.name, req.schedule.input);\n      try {\n        await (await this.stateStore()).save(flowId, state);\n        await this.scheduler(\n          this,\n          { runScheduled: { flowId } } as FlowInvokeEnvelopeMessage,\n          req.schedule.delay\n        );\n      } catch (e) {\n        state.operation.done = true;\n        state.operation.result = {\n          error: getErrorMessage(e),\n          stacktrace: getErrorStack(e),\n        };\n        await (await this.stateStore()).save(flowId, state);\n      }\n      return state;\n    }\n    if (req.state) {\n      if (!this.experimentalDurable) {\n        throw new Error('Cannot state check a non-durable flow');\n      }\n      if (!this.stateStore) {\n        throw new Error(\n          'Flow state store for durable flows must be configured'\n        );\n      }\n      const flowId = req.state.flowId;\n      const state = await (await this.stateStore()).load(flowId);\n      if (state === undefined) {\n        throw new Error(`Unable to find flow state for ${flowId}`);\n      }\n      return state;\n    }\n    if (req.runScheduled) {\n      if (!this.experimentalDurable) {\n        throw new Error('Cannot run scheduled non-durable flow');\n      }\n      if (!this.stateStore) {\n        throw new Error(\n          'Flow state store for durable flows must be configured'\n        );\n      }\n      const flowId = req.runScheduled.flowId;\n      const state = await (await this.stateStore()).load(flowId);\n      if (state === undefined) {\n        throw new Error(`Unable to find flow state for ${flowId}`);\n      }\n      const ctx = new Context(this, flowId, state);\n      try {\n        await this.executeSteps(\n          ctx,\n          this.steps,\n          'runScheduled',\n          undefined,\n          undefined\n        );\n      } finally {\n        await ctx.saveState();\n      }\n      return state;\n    }\n    if (req.resume) {\n      if (!this.experimentalDurable) {\n        throw new Error('Cannot resume a non-durable flow');\n      }\n      if (!this.stateStore) {\n        throw new Error(\n          'Flow state store for durable flows must be configured'\n        );\n      }\n      const flowId = req.resume.flowId;\n      const state = await (await this.stateStore()).load(flowId);\n      if (state === undefined) {\n        throw new Error(`Unable to find flow state for ${flowId}`);\n      }\n      if (!state.blockedOnStep) {\n        throw new Error(\n          \"Unable to resume flow that's currently not interrupted\"\n        );\n      }\n      state.eventsTriggered[state.blockedOnStep.name] = req.resume.payload;\n      const ctx = new Context(this, flowId, state);\n      try {\n        await this.executeSteps(\n          ctx,\n          this.steps,\n          'resume',\n          undefined,\n          undefined\n        );\n      } finally {\n        await ctx.saveState();\n      }\n      return state;\n    }\n    // TODO: add retry\n\n    throw new Error(\n      'Unexpected envelope message case, must set one of: ' +\n        'start, schedule, runScheduled, resume, retry, state'\n    );\n  }\n\n  // TODO: refactor me... this is a mess!\n  private async executeSteps(\n    ctx: Context<I, O, S>,\n    handler: StepsFunction<I, O, S>,\n    dispatchType: string,\n    streamingCallback: StreamingCallback<any> | undefined,\n    labels: Record<string, string> | undefined\n  ) {\n    const startTimeMs = performance.now();\n    await runWithActiveContext(ctx, async () => {\n      let traceContext;\n      if (ctx.state.traceContext) {\n        traceContext = JSON.parse(ctx.state.traceContext);\n      }\n      let ctxLinks = traceContext ? [{ context: traceContext }] : [];\n      let errored = false;\n      const output = await newTrace(\n        {\n          name: ctx.flow.name,\n          labels: {\n            [SPAN_TYPE_ATTR]: 'flow',\n          },\n          links: ctxLinks,\n        },\n        async (metadata, rootSpan) => {\n          ctx.state.executions.push({\n            startTime: Date.now(),\n            traceIds: [],\n          });\n          setCustomMetadataAttribute(\n            metadataPrefix(`execution`),\n            (ctx.state.executions.length - 1).toString()\n          );\n          if (labels) {\n            Object.keys(labels).forEach((label) => {\n              setCustomMetadataAttribute(\n                metadataPrefix(`label:${label}`),\n                labels[label]\n              );\n            });\n          }\n\n          setCustomMetadataAttributes({\n            [metadataPrefix('name')]: this.name,\n            [metadataPrefix('id')]: ctx.flowId,\n          });\n          ctx\n            .getCurrentExecution()\n            .traceIds.push(rootSpan.spanContext().traceId);\n          // Save the trace in the state so that we can tie subsequent invocation together.\n          if (!traceContext) {\n            ctx.state.traceContext = JSON.stringify(rootSpan.spanContext());\n          }\n          setCustomMetadataAttribute(\n            metadataPrefix('dispatchType'),\n            dispatchType\n          );\n          try {\n            const input = this.inputSchema\n              ? this.inputSchema.parse(ctx.state.input)\n              : ctx.state.input;\n            metadata.input = input;\n            const output = await handler(input, streamingCallback);\n            metadata.output = JSON.stringify(output);\n            setCustomMetadataAttribute(metadataPrefix('state'), 'done');\n            telemetry.writeFlowSuccess(\n              ctx.flow.name,\n              performance.now() - startTimeMs\n            );\n            return output;\n          } catch (e) {\n            if (e instanceof InterruptError) {\n              setCustomMetadataAttribute(\n                metadataPrefix('state'),\n                'interrupted'\n              );\n              // Log interrupted\n            } else {\n              metadata.state = 'error';\n              rootSpan.setStatus({\n                code: SpanStatusCode.ERROR,\n                message: getErrorMessage(e),\n              });\n              if (e instanceof Error) {\n                rootSpan.recordException(e);\n              }\n\n              setCustomMetadataAttribute(metadataPrefix('state'), 'error');\n              ctx.state.operation.done = true;\n              ctx.state.operation.result = {\n                error: getErrorMessage(e),\n                stacktrace: getErrorStack(e),\n              } as FlowError;\n\n              telemetry.recordError(e);\n              telemetry.writeFlowFailure(\n                ctx.flow.name,\n                performance.now() - startTimeMs,\n                e\n              );\n            }\n            errored = true;\n          }\n        }\n      );\n      if (!errored) {\n        // flow done, set response.\n        ctx.state.operation.done = true;\n        ctx.state.operation.result = { response: output };\n      }\n    });\n  }\n\n  private async durableExpressHandler(\n    req: express.Request,\n    res: express.Response\n  ): Promise<void> {\n    telemetry.logRequest(this.name, req);\n    if (req.query.stream === 'true') {\n      const respBody = {\n        error: {\n          status: 'INVALID_ARGUMENT',\n          message: 'Output from durable flows cannot be streamed',\n        },\n      };\n      res.status(400).send(respBody).end();\n      telemetry.logResponse(this.name, 400, respBody);\n      return;\n    }\n\n    let data = req.body;\n    // Task queue will wrap body in a \"data\" object, unwrap it.\n    if (req.body.data) {\n      data = req.body.data;\n    }\n    const envMsg = FlowInvokeEnvelopeMessageSchema.parse(data);\n    try {\n      const state = await this.runEnvelope(envMsg);\n      res.status(200).send(state.operation).end();\n      telemetry.logResponse(this.name, 200, state.operation);\n    } catch (e) {\n      // Pass errors as operations instead of a standard API error\n      // (https://cloud.google.com/apis/design/errors#http_mapping)\n      telemetry.recordError(e);\n      const respBody = {\n        done: true,\n        result: {\n          error: getErrorMessage(e),\n          stacktrace: getErrorStack(e),\n        },\n      };\n      res\n        .status(500)\n        .send(respBody as Operation)\n        .end();\n      telemetry.logResponse(this.name, 500, respBody);\n    }\n  }\n\n  private async nonDurableExpressHandler(\n    req: __RequestWithAuth,\n    res: express.Response\n  ): Promise<void> {\n    telemetry.logRequest(this.name, req);\n    const { stream } = req.query;\n    const auth = req.auth;\n\n    let input = req.body.data;\n\n    try {\n      await this.authPolicy?.(auth, input);\n    } catch (e: any) {\n      telemetry.recordError(e);\n      const respBody = {\n        error: {\n          status: 'PERMISSION_DENIED',\n          message: e.message || 'Permission denied to resource',\n        },\n      };\n      res.status(403).send(respBody).end();\n      telemetry.logResponse(this.name, 403, respBody);\n    }\n\n    if (stream === 'true') {\n      res.writeHead(200, {\n        'Content-Type': 'text/plain',\n        'Transfer-Encoding': 'chunked',\n      });\n      try {\n        const state = await this.runDirectly(input, {\n          streamingCallback: (chunk) => {\n            res.write(JSON.stringify(chunk) + streamDelimiter);\n          },\n          auth,\n        });\n        res.write(JSON.stringify(state.operation));\n        res.end();\n        telemetry.logResponse(this.name, 200, state.operation);\n      } catch (e) {\n        // Errors while streaming are also passed back as operations\n        telemetry.recordError(e);\n        const respBody = {\n          done: true,\n          result: {\n            error: getErrorMessage(e),\n            stacktrace: getErrorStack(e),\n          },\n        };\n        res.write(JSON.stringify(respBody as Operation));\n        res.end();\n        telemetry.logResponse(this.name, 500, respBody);\n      }\n    } else {\n      try {\n        const state = await this.runDirectly(input, { auth });\n        if (state.operation.result?.error) {\n          throw new Error(state.operation.result?.error);\n        }\n        // Responses for non-streaming, non-durable flows are passed back\n        // with the flow result stored in a field called \"result.\"\n        res\n          .status(200)\n          .send({\n            result: state.operation.result?.response,\n          })\n          .end();\n        telemetry.logResponse(this.name, 200, state.operation);\n      } catch (e) {\n        // Errors for non-durable, non-streaming flows are passed back as\n        // standard API errors.\n        telemetry.recordError(e);\n        res\n          .status(500)\n          .send({\n            error: {\n              status: 'INTERNAL',\n              message: getErrorMessage(e),\n              details: getErrorStack(e),\n            },\n          })\n          .end();\n      }\n    }\n  }\n\n  get expressHandler(): (\n    req: __RequestWithAuth,\n    res: express.Response\n  ) => Promise<void> {\n    return this.experimentalDurable\n      ? this.durableExpressHandler.bind(this)\n      : this.nonDurableExpressHandler.bind(this);\n  }\n}\n\n/**\n * Runs the flow. If the flow does not get interrupted may return a completed (done=true) operation.\n */\nexport async function runFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  flow: Flow<I, O, S> | FlowWrapper<I, O, S>,\n  payload?: z.infer<I>,\n  opts?: { withLocalAuthContext?: unknown }\n): Promise<z.infer<O>> {\n  if (!(flow instanceof Flow)) {\n    flow = flow.flow;\n  }\n\n  const input = flow.inputSchema ? flow.inputSchema.parse(payload) : payload;\n  await flow.authPolicy?.(opts?.withLocalAuthContext, payload);\n\n  if (flow.middleware) {\n    logger.warn(\n      `Flow (${flow.name}) middleware won't run when invoked with runFlow.`\n    );\n  }\n\n  const state = await flow.runEnvelope({\n    start: {\n      input,\n    },\n  });\n  if (!state.operation.done) {\n    throw new FlowStillRunningError(\n      `flow ${state.name} did not finish execution`\n    );\n  }\n  if (state.operation.result?.error) {\n    throw new FlowExecutionError(\n      state.operation.name,\n      state.operation.result?.error,\n      state.operation.result?.stacktrace\n    );\n  }\n  return state.operation.result?.response;\n}\n\ninterface StreamingResponse<\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> {\n  stream(): AsyncGenerator<unknown, Operation, z.infer<S> | undefined>;\n  output(): Promise<z.infer<O>>;\n}\n\n/**\n * Runs the flow and streams results. If the flow does not get interrupted may return a completed (done=true) operation.\n */\nexport function streamFlow<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  flow: Flow<I, O, S> | FlowWrapper<I, O, S>,\n  payload?: z.infer<I>\n): StreamingResponse<O, S> {\n  if (!(flow instanceof Flow)) {\n    flow = flow.flow;\n  }\n\n  let chunkStreamController: ReadableStreamController<z.infer<S>>;\n  const chunkStream = new ReadableStream<z.infer<S>>({\n    start(controller) {\n      chunkStreamController = controller;\n    },\n    pull() {},\n    cancel() {},\n  });\n\n  const operationPromise = flow\n    .runEnvelope(\n      {\n        start: {\n          input: flow.inputSchema ? flow.inputSchema.parse(payload) : payload,\n        },\n      },\n      (c) => {\n        chunkStreamController.enqueue(c);\n      }\n    )\n    .then((s) => s.operation);\n  operationPromise.then((o) => {\n    chunkStreamController.close();\n    return o;\n  });\n\n  return {\n    output() {\n      return operationPromise.then((op) => {\n        if (!op.done) {\n          throw new FlowStillRunningError(\n            `flow ${op.name} did not finish execution`\n          );\n        }\n        if (op.result?.error) {\n          throw new FlowExecutionError(\n            op.name,\n            op.result?.error,\n            op.result?.stacktrace\n          );\n        }\n        return op.result?.response;\n      });\n    },\n    async *stream() {\n      const reader = chunkStream.getReader();\n      while (true) {\n        const chunk = await reader.read();\n        if (chunk.value) {\n          yield chunk.value;\n        }\n        if (chunk.done) {\n          break;\n        }\n      }\n      return await operationPromise;\n    },\n  };\n}\n\nfunction createNewState(\n  flowId: string,\n  name: string,\n  input: unknown\n): FlowState {\n  return {\n    flowId: flowId,\n    name: name,\n    startTime: Date.now(),\n    input: input,\n    cache: {},\n    eventsTriggered: {},\n    blockedOnStep: null,\n    executions: [],\n    operation: {\n      name: flowId,\n      done: false,\n    },\n  };\n}\n\nexport type StepsFunction<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n> = (\n  input: z.infer<I>,\n  streamingCallback: StreamingCallback<z.infer<S>> | undefined\n) => Promise<z.infer<O>>;\n\nfunction wrapAsAction<\n  I extends z.ZodTypeAny = z.ZodTypeAny,\n  O extends z.ZodTypeAny = z.ZodTypeAny,\n  S extends z.ZodTypeAny = z.ZodTypeAny,\n>(\n  flow: Flow<I, O, S>\n): Action<typeof FlowActionInputSchema, typeof FlowStateSchema> {\n  return defineAction(\n    {\n      actionType: 'flow',\n      name: flow.name,\n      inputSchema: FlowActionInputSchema,\n      outputSchema: FlowStateSchema,\n      metadata: {\n        inputSchema: toJsonSchema({ schema: flow.inputSchema }),\n        outputSchema: toJsonSchema({ schema: flow.outputSchema }),\n        experimentalDurable: !!flow.experimentalDurable,\n      },\n    },\n    async (envelope) => {\n      // Only non-durable flows have an authPolicy, so envelope.start should always\n      // be defined here.\n      await flow.authPolicy?.(\n        envelope.auth,\n        envelope.start?.input as I | undefined\n      );\n      setCustomMetadataAttribute(metadataPrefix('wrapperAction'), 'true');\n      return await flow.runEnvelope(\n        envelope,\n        getStreamingCallback(),\n        envelope.auth\n      );\n    }\n  );\n}\n\nexport function startFlowsServer(params?: {\n  flows?: Flow<any, any, any>[];\n  port?: number;\n  cors?: CorsOptions;\n  pathPrefix?: string;\n}) {\n  const port =\n    params?.port || (process.env.PORT ? parseInt(process.env.PORT) : 0) || 3400;\n  const pathPrefix = params?.pathPrefix ?? '';\n  const app = express();\n  app.use(bodyParser.json());\n  app.use(cors(params?.cors));\n\n  const flows = params?.flows || createdFlows();\n  logger.info(`Starting flows server on port ${port}`);\n  flows.forEach((f) => {\n    const flowPath = `/${pathPrefix}${f.name}`;\n    logger.info(` - ${flowPath}`);\n    // Add middlware\n    f.middleware?.forEach((m) => {\n      app.post(flowPath, m);\n    });\n    app.post(flowPath, f.expressHandler);\n  });\n\n  app.listen(port, () => {\n    console.log(`Flows server listening on port ${port}`);\n  });\n}\n"],"mappings":"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","names":["globalConfig","output","_a","express","cors"]}