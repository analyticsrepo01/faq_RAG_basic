import { Operation, Action } from '@genkit-ai/core';
import * as z from 'zod';
import { PollingConfig } from './context.mjs';
import { I as Invoker, g as Scheduler, S as StepsFunction, F as Flow, c as FlowWrapper, R as RunStepConfig } from './flow-tt-MohJ-.mjs';
import 'cors';
import 'express';

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Defines the durable flow.
 */
declare function durableFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(config: {
    name: string;
    inputSchema?: I;
    outputSchema?: O;
    streamSchema?: S;
    invoker?: Invoker<I, O, S>;
    scheduler?: Scheduler<I, O, S>;
}, steps: StepsFunction<I, O, S>): Flow<I, O, S>;
/**
 * Schedules a flow run. This is always return an operation that's not completed (done=false).
 */
declare function scheduleFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(flow: Flow<I, O, S> | FlowWrapper<I, O, S>, payload: z.infer<I>, delaySeconds?: number): Promise<Operation>;
/**
 * Resumes an interrupted flow.
 */
declare function resumeFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(flow: Flow<I, O, S> | FlowWrapper<I, O, S>, flowId: string, payload: any): Promise<Operation>;
/**
 * Returns an operation representing current state of the flow.
 */
declare function getFlowState<I extends z.ZodTypeAny, O extends z.ZodTypeAny, S extends z.ZodTypeAny>(flow: Flow<I, O, S> | FlowWrapper<I, O, S>, flowId: string): Promise<Operation>;
/**
 * A flow steap that executes an action with provided input and memoizes the output.
 */
declare function runAction<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(action: Action<I, O>, input: z.infer<I>, actionConfig?: RunStepConfig): Promise<z.infer<O>>;
/**
 * A local utility that waits for the flow execution to complete. If flow errored then a
 * {@link FlowExecutionError} will be thrown.
 */
declare function waitFlowToComplete<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(flow: Flow<I, O, S> | FlowWrapper<I, O, S>, flowId: string): Promise<z.infer<O>>;
declare function run<T>(experimentalConfig: RunStepConfig, func: () => Promise<T>): Promise<T>;
declare function run<T>(experimentalConfig: RunStepConfig, input: any | undefined, func: () => Promise<T>): Promise<T>;
declare function run<T>(name: string, func: () => Promise<T>): Promise<T>;
/**
 * Interrupts the flow execution until the flow is resumed with input defined by `responseSchema`.
 */
declare function interrupt<I extends z.ZodTypeAny, O extends z.ZodTypeAny>(stepName: string, responseSchema: I, func?: (payload: z.infer<I>) => Promise<z.infer<O>>): Promise<z.infer<O>>;
/**
 * Interrupts flow execution and resumes it when specified amount if time elapses.
 */
declare function sleep(actionId: string, durationMs: number): Promise<z.ZodTypeAny>;
/**
 * Interrupts the flow and periodically check for the flow ID to complete.
 */
declare function waitFor(stepName: string, flow: Flow<z.ZodTypeAny, z.ZodTypeAny, z.ZodTypeAny>, flowIds: string[], pollingConfig?: PollingConfig): Promise<Operation[]>;
declare function asyncSleep(duration: number): Promise<unknown>;

export { asyncSleep, durableFlow, getFlowState, interrupt, resumeFlow, run, runAction, scheduleFlow, sleep, waitFlowToComplete, waitFor };
