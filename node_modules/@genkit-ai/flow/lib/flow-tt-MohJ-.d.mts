import { StreamingCallback, Operation, FlowStateStore, FlowState } from '@genkit-ai/core';
import { CorsOptions } from 'cors';
import express from 'express';
import * as z from 'zod';
import { z as z$1 } from 'zod';

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

type Invoker<I extends z$1.ZodTypeAny = z$1.ZodTypeAny, O extends z$1.ZodTypeAny = z$1.ZodTypeAny, S extends z$1.ZodTypeAny = z$1.ZodTypeAny> = (flow: Flow<I, O, S>, msg: FlowInvokeEnvelopeMessage, streamingCallback?: StreamingCallback<any>) => Promise<Operation>;
type Scheduler<I extends z$1.ZodTypeAny = z$1.ZodTypeAny, O extends z$1.ZodTypeAny = z$1.ZodTypeAny, S extends z$1.ZodTypeAny = z$1.ZodTypeAny> = (flow: Flow<I, O, S>, msg: FlowInvokeEnvelopeMessage, delaySeconds?: number) => Promise<void>;
/**
 * The message format used by the flow task queue and control interface.
 */
declare const FlowInvokeEnvelopeMessageSchema: z$1.ZodObject<{
    start: z$1.ZodOptional<z$1.ZodObject<{
        input: z$1.ZodOptional<z$1.ZodUnknown>;
        labels: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodString>>;
    }, "strip", z$1.ZodTypeAny, {
        input?: unknown;
        labels?: Record<string, string> | undefined;
    }, {
        input?: unknown;
        labels?: Record<string, string> | undefined;
    }>>;
    schedule: z$1.ZodOptional<z$1.ZodObject<{
        input: z$1.ZodOptional<z$1.ZodUnknown>;
        delay: z$1.ZodOptional<z$1.ZodNumber>;
    }, "strip", z$1.ZodTypeAny, {
        input?: unknown;
        delay?: number | undefined;
    }, {
        input?: unknown;
        delay?: number | undefined;
    }>>;
    runScheduled: z$1.ZodOptional<z$1.ZodObject<{
        flowId: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        flowId: string;
    }, {
        flowId: string;
    }>>;
    retry: z$1.ZodOptional<z$1.ZodObject<{
        flowId: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        flowId: string;
    }, {
        flowId: string;
    }>>;
    resume: z$1.ZodOptional<z$1.ZodObject<{
        flowId: z$1.ZodString;
        payload: z$1.ZodOptional<z$1.ZodUnknown>;
    }, "strip", z$1.ZodTypeAny, {
        flowId: string;
        payload?: unknown;
    }, {
        flowId: string;
        payload?: unknown;
    }>>;
    state: z$1.ZodOptional<z$1.ZodObject<{
        flowId: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        flowId: string;
    }, {
        flowId: string;
    }>>;
}, "strip", z$1.ZodTypeAny, {
    start?: {
        input?: unknown;
        labels?: Record<string, string> | undefined;
    } | undefined;
    schedule?: {
        input?: unknown;
        delay?: number | undefined;
    } | undefined;
    runScheduled?: {
        flowId: string;
    } | undefined;
    retry?: {
        flowId: string;
    } | undefined;
    resume?: {
        flowId: string;
        payload?: unknown;
    } | undefined;
    state?: {
        flowId: string;
    } | undefined;
}, {
    start?: {
        input?: unknown;
        labels?: Record<string, string> | undefined;
    } | undefined;
    schedule?: {
        input?: unknown;
        delay?: number | undefined;
    } | undefined;
    runScheduled?: {
        flowId: string;
    } | undefined;
    retry?: {
        flowId: string;
    } | undefined;
    resume?: {
        flowId: string;
        payload?: unknown;
    } | undefined;
    state?: {
        flowId: string;
    } | undefined;
}>;
type FlowInvokeEnvelopeMessage = z$1.infer<typeof FlowInvokeEnvelopeMessageSchema>;
declare const FlowActionInputSchema: z$1.ZodObject<{
    state: z$1.ZodOptional<z$1.ZodObject<{
        flowId: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        flowId: string;
    }, {
        flowId: string;
    }>>;
    start: z$1.ZodOptional<z$1.ZodObject<{
        input: z$1.ZodOptional<z$1.ZodUnknown>;
        labels: z$1.ZodOptional<z$1.ZodRecord<z$1.ZodString, z$1.ZodString>>;
    }, "strip", z$1.ZodTypeAny, {
        input?: unknown;
        labels?: Record<string, string> | undefined;
    }, {
        input?: unknown;
        labels?: Record<string, string> | undefined;
    }>>;
    schedule: z$1.ZodOptional<z$1.ZodObject<{
        input: z$1.ZodOptional<z$1.ZodUnknown>;
        delay: z$1.ZodOptional<z$1.ZodNumber>;
    }, "strip", z$1.ZodTypeAny, {
        input?: unknown;
        delay?: number | undefined;
    }, {
        input?: unknown;
        delay?: number | undefined;
    }>>;
    runScheduled: z$1.ZodOptional<z$1.ZodObject<{
        flowId: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        flowId: string;
    }, {
        flowId: string;
    }>>;
    retry: z$1.ZodOptional<z$1.ZodObject<{
        flowId: z$1.ZodString;
    }, "strip", z$1.ZodTypeAny, {
        flowId: string;
    }, {
        flowId: string;
    }>>;
    resume: z$1.ZodOptional<z$1.ZodObject<{
        flowId: z$1.ZodString;
        payload: z$1.ZodOptional<z$1.ZodUnknown>;
    }, "strip", z$1.ZodTypeAny, {
        flowId: string;
        payload?: unknown;
    }, {
        flowId: string;
        payload?: unknown;
    }>>;
    auth: z$1.ZodOptional<z$1.ZodUnknown>;
}, "strip", z$1.ZodTypeAny, {
    state?: {
        flowId: string;
    } | undefined;
    start?: {
        input?: unknown;
        labels?: Record<string, string> | undefined;
    } | undefined;
    schedule?: {
        input?: unknown;
        delay?: number | undefined;
    } | undefined;
    runScheduled?: {
        flowId: string;
    } | undefined;
    retry?: {
        flowId: string;
    } | undefined;
    resume?: {
        flowId: string;
        payload?: unknown;
    } | undefined;
    auth?: unknown;
}, {
    state?: {
        flowId: string;
    } | undefined;
    start?: {
        input?: unknown;
        labels?: Record<string, string> | undefined;
    } | undefined;
    schedule?: {
        input?: unknown;
        delay?: number | undefined;
    } | undefined;
    runScheduled?: {
        flowId: string;
    } | undefined;
    retry?: {
        flowId: string;
    } | undefined;
    resume?: {
        flowId: string;
        payload?: unknown;
    } | undefined;
    auth?: unknown;
}>;
/**
 * Retry options for flows and steps.
 */
interface RetryConfig {
    /**
     * Maximum number of times a request should be attempted.
     * If left unspecified, will default to 3.
     */
    maxAttempts?: number;
    /**
     * Maximum amount of time for retrying failed task.
     * If left unspecified will retry indefinitely.
     */
    maxRetrySeconds?: number;
    /**
     * The maximum amount of time to wait between attempts.
     * If left unspecified will default to 1hr.
     */
    maxBackoffSeconds?: number;
    /**
     * The maximum number of times to double the backoff between
     * retries. If left unspecified will default to 16.
     */
    maxDoublings?: number;
    /**
     * The minimum time to wait between attempts. If left unspecified
     * will default to 100ms.
     */
    minBackoffSeconds?: number;
}

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Step configuration for retries, etc.
 */
interface RunStepConfig {
    name: string;
    retryConfig?: RetryConfig;
}
/**
 * Flow Auth policy. Consumes the authorization context of the flow and
 * performs checks before the flow runs. If this throws, the flow will not
 * be executed.
 */
interface FlowAuthPolicy<I extends z.ZodTypeAny = z.ZodTypeAny> {
    (auth: any | undefined, input: z.infer<I>): void | Promise<void>;
}
/**
 * For express-based flows, req.auth should contain the value to bepassed into
 * the flow context.
 */
interface __RequestWithAuth extends express.Request {
    auth?: unknown;
}
/**
 * Defines the flow.
 */
declare function defineFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(config: {
    name: string;
    inputSchema?: I;
    outputSchema?: O;
    streamSchema?: S;
    authPolicy?: FlowAuthPolicy<I>;
    middleware?: express.RequestHandler[];
    invoker?: Invoker<I, O, S>;
    experimentalDurable?: boolean;
    experimentalScheduler?: Scheduler<I, O, S>;
}, steps: StepsFunction<I, O, S>): Flow<I, O, S>;
interface FlowWrapper<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> {
    flow: Flow<I, O, S>;
}
declare class Flow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> {
    private steps;
    readonly name: string;
    readonly inputSchema?: I;
    readonly outputSchema?: O;
    readonly streamSchema?: S;
    readonly stateStore?: () => Promise<FlowStateStore>;
    readonly invoker: Invoker<I, O, S>;
    readonly scheduler: Scheduler<I, O, S>;
    readonly experimentalDurable: boolean;
    readonly authPolicy?: FlowAuthPolicy<I>;
    readonly middleware?: express.RequestHandler[];
    constructor(config: {
        name: string;
        inputSchema?: I;
        outputSchema?: O;
        streamSchema?: S;
        stateStore?: () => Promise<FlowStateStore>;
        invoker: Invoker<I, O, S>;
        scheduler: Scheduler<I, O, S>;
        experimentalDurable: boolean;
        authPolicy?: FlowAuthPolicy<I>;
        middleware?: express.RequestHandler[];
    }, steps: StepsFunction<I, O, S>);
    /**
     * Executes the flow with the input directly.
     *
     * This will either be called by runEnvelope when starting durable flows,
     * or it will be called directly when starting non-durable flows.
     */
    runDirectly(input: unknown, opts: {
        streamingCallback?: StreamingCallback<unknown>;
        labels?: Record<string, string>;
        auth?: unknown;
    }): Promise<FlowState>;
    /**
     * Executes the flow with the input in the envelope format.
     */
    runEnvelope(req: FlowInvokeEnvelopeMessage, streamingCallback?: StreamingCallback<any>, auth?: unknown): Promise<FlowState>;
    private executeSteps;
    private durableExpressHandler;
    private nonDurableExpressHandler;
    get expressHandler(): (req: __RequestWithAuth, res: express.Response) => Promise<void>;
}
/**
 * Runs the flow. If the flow does not get interrupted may return a completed (done=true) operation.
 */
declare function runFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(flow: Flow<I, O, S> | FlowWrapper<I, O, S>, payload?: z.infer<I>, opts?: {
    withLocalAuthContext?: unknown;
}): Promise<z.infer<O>>;
interface StreamingResponse<O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> {
    stream(): AsyncGenerator<unknown, Operation, z.infer<S> | undefined>;
    output(): Promise<z.infer<O>>;
}
/**
 * Runs the flow and streams results. If the flow does not get interrupted may return a completed (done=true) operation.
 */
declare function streamFlow<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny>(flow: Flow<I, O, S> | FlowWrapper<I, O, S>, payload?: z.infer<I>): StreamingResponse<O, S>;
type StepsFunction<I extends z.ZodTypeAny = z.ZodTypeAny, O extends z.ZodTypeAny = z.ZodTypeAny, S extends z.ZodTypeAny = z.ZodTypeAny> = (input: z.infer<I>, streamingCallback: StreamingCallback<z.infer<S>> | undefined) => Promise<z.infer<O>>;
declare function startFlowsServer(params?: {
    flows?: Flow<any, any, any>[];
    port?: number;
    cors?: CorsOptions;
    pathPrefix?: string;
}): void;

export { Flow as F, type Invoker as I, type RunStepConfig as R, type StepsFunction as S, type __RequestWithAuth as _, streamFlow as a, type FlowAuthPolicy as b, type FlowWrapper as c, defineFlow as d, FlowInvokeEnvelopeMessageSchema as e, type FlowInvokeEnvelopeMessage as f, type Scheduler as g, FlowActionInputSchema as h, type RetryConfig as i, runFlow as r, startFlowsServer as s };
