{"version":3,"sources":["../src/prompt.ts"],"sourcesContent":["/**\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  definePrompt,\n  generate,\n  GenerateOptions,\n  GenerateResponse,\n  generateStream,\n  GenerateStreamResponse,\n  PromptAction,\n  toGenerateRequest,\n} from '@genkit-ai/ai';\nimport { GenerationCommonConfigSchema, MessageData } from '@genkit-ai/ai/model';\nimport { DocumentData } from '@genkit-ai/ai/retriever';\nimport { GenkitError } from '@genkit-ai/core';\nimport { parseSchema } from '@genkit-ai/core/schema';\nimport { createHash } from 'crypto';\nimport fm, { FrontMatterResult } from 'front-matter';\nimport z from 'zod';\nimport {\n  PromptFrontmatter,\n  PromptMetadata,\n  toFrontmatter,\n  toMetadata,\n} from './metadata.js';\nimport { registryDefinitionKey } from './registry.js';\nimport { compile } from './template.js';\n\nexport type PromptData = PromptFrontmatter & { template: string };\n\nexport type PromptGenerateOptions<V = unknown> = Omit<\n  GenerateOptions<z.ZodTypeAny, typeof GenerationCommonConfigSchema>,\n  'prompt' | 'history' | 'model'\n> & {\n  model?: string;\n  input?: V;\n};\n\nexport class Dotprompt<Variables = unknown> implements PromptMetadata {\n  name: string;\n  variant?: string;\n  hash: string;\n\n  template: string;\n\n  model?: PromptMetadata['model'];\n  metadata: PromptMetadata['metadata'];\n  input?: PromptMetadata['input'];\n  output?: PromptMetadata['output'];\n  tools?: PromptMetadata['tools'];\n  config?: PromptMetadata['config'];\n  candidates?: PromptMetadata['candidates'];\n\n  private _render: (input: Variables) => MessageData[];\n\n  static parse(name: string, source: string) {\n    try {\n      const fmResult = (fm as any)(source.trimStart(), {\n        allowUnsafe: false,\n      }) as FrontMatterResult<unknown>;\n\n      return new Dotprompt(\n        { ...toMetadata(fmResult.attributes), name } as PromptMetadata,\n        fmResult.body\n      );\n    } catch (e: any) {\n      throw new GenkitError({\n        source: 'Dotprompt',\n        status: 'INVALID_ARGUMENT',\n        message: `Error parsing YAML frontmatter of '${name}' prompt: ${e.message}`,\n      });\n    }\n  }\n\n  static fromAction(action: PromptAction): Dotprompt {\n    const { template, ...options } = action.__action.metadata!.prompt;\n    const pm = options as PromptMetadata;\n    if (pm.input?.schema) {\n      pm.input.jsonSchema = options.input?.schema;\n      delete pm.input.schema;\n    }\n    if (pm.output?.schema) {\n      pm.output.jsonSchema = options.output?.schema;\n    }\n    const prompt = new Dotprompt(options as PromptMetadata, template);\n    return prompt;\n  }\n\n  constructor(options: PromptMetadata, template: string) {\n    this.name = options.name || 'untitledPrompt';\n    this.variant = options.variant;\n    this.model = options.model;\n    this.input = options.input || { schema: z.any() };\n    this.output = options.output;\n    this.tools = options.tools;\n    this.config = options.config;\n    this.candidates = options.candidates;\n    this.template = template;\n    this.hash = createHash('sha256').update(JSON.stringify(this)).digest('hex');\n\n    this._render = compile(this.template, options);\n  }\n\n  renderText(input: Variables, context?: DocumentData[]): string {\n    const result = this.renderMessages(input, context);\n    if (result.length !== 1) {\n      throw new Error(\"Multi-message prompt can't be rendered as text.\");\n    }\n    let out = '';\n    for (const part of result[0].content) {\n      if (!part.text) {\n        throw new Error(\"Multimodal prompt can't be rendered as text.\");\n      }\n      out += part.text;\n    }\n    return out;\n  }\n\n  renderMessages(input?: Variables, context?: DocumentData[]): MessageData[] {\n    input = parseSchema(input, {\n      schema: this.input?.schema,\n      jsonSchema: this.input?.jsonSchema,\n    });\n    return this._render({ ...this.input?.default, ...input });\n  }\n\n  toJSON(): PromptData {\n    return { ...toFrontmatter(this), template: this.template };\n  }\n\n  define(options?: { ns: string }): void {\n    definePrompt(\n      {\n        name: registryDefinitionKey(this.name, this.variant, options?.ns),\n        description: 'Defined by Dotprompt',\n        inputSchema: this.input?.schema,\n        inputJsonSchema: this.input?.jsonSchema,\n        metadata: {\n          type: 'prompt',\n          prompt: this.toJSON(),\n        },\n      },\n      async (input?: Variables) => toGenerateRequest(this.render({ input }))\n    );\n  }\n\n  private _generateOptions(\n    options: PromptGenerateOptions<Variables>\n  ): GenerateOptions {\n    const messages = this.renderMessages(options.input);\n    return {\n      model: options.model || this.model!,\n      config: { ...this.config, ...options.config } || {},\n      history: messages.slice(0, messages.length - 1),\n      prompt: messages[messages.length - 1].content,\n      context: options.context,\n      candidates: options.candidates || this.candidates || 1,\n      output: {\n        format: options.output?.format || this.output?.format || undefined,\n        schema: options.output?.schema || this.output?.schema,\n        jsonSchema: options.output?.jsonSchema || this.output?.jsonSchema,\n      },\n      tools: (options.tools || []).concat(this.tools || []),\n      streamingCallback: options.streamingCallback,\n      returnToolRequests: options.returnToolRequests,\n    };\n  }\n\n  render(opt: PromptGenerateOptions<Variables>): GenerateOptions {\n    return this._generateOptions(opt);\n  }\n\n  async generate(\n    opt: PromptGenerateOptions<Variables>\n  ): Promise<GenerateResponse> {\n    return generate(this.render(opt));\n  }\n\n  async generateStream(\n    opt: PromptGenerateOptions<Variables>\n  ): Promise<GenerateStreamResponse> {\n    return generateStream(this.render(opt));\n  }\n}\n\nexport function defineDotprompt<V extends z.ZodTypeAny = z.ZodTypeAny>(\n  options: PromptMetadata<V>,\n  template: string\n): Dotprompt<z.infer<V>> {\n  const prompt = new Dotprompt(options, template);\n  prompt.define();\n  return prompt;\n}\n"],"mappings":"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","names":["fm","z"]}