import { ModelArgument } from '@genkit-ai/ai/model';
import { ToolArgument } from '@genkit-ai/ai/tool';
import { JSONSchema } from '@genkit-ai/core/schema';
import z from 'zod';

/**
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Metadata for a prompt.
 */
interface PromptMetadata<Input extends z.ZodTypeAny = z.ZodTypeAny, Options extends z.ZodTypeAny = z.ZodTypeAny> {
    /** The name of the prompt. */
    name?: string;
    /** The variant name for the prompt. */
    variant?: string;
    /** The name of the model to use for this prompt, e.g. `vertexai/gemini-1.0-pro` */
    model?: ModelArgument<Options>;
    /** Names of tools (registered separately) to allow use of in this prompt. */
    tools?: ToolArgument[];
    /** Number of candidates to generate by default. */
    candidates?: number;
    /** Model configuration. Not all models support all options. */
    config?: z.infer<Options>;
    input?: {
        /** Defines the default input variable values to use if none are provided. */
        default?: any;
        /** Zod schema defining the input variables. */
        schema?: Input;
        /**
         * Defines the input variables that can be passed into the template in JSON schema form.
         * If not supplied, any object will be accepted. `{type: "object"}` is defaulted if not
         * supplied.
         */
        jsonSchema?: JSONSchema;
    };
    /** Defines the expected model output format. */
    output?: {
        /** Desired output format for this prompt. */
        format?: 'json' | 'text' | 'media';
        /** Zod schema defining the output structure (cannot be specified with non-json format). */
        schema?: z.ZodTypeAny;
        /** JSON schema of desired output (cannot be specified with non-json format). */
        jsonSchema?: JSONSchema;
    };
    /** Arbitrary metadata to be used by code, tools, and libraries. */
    metadata?: Record<string, any>;
}
/**
 * Formal schema for prompt YAML frontmatter.
 */
declare const PromptFrontmatterSchema: z.ZodObject<{
    name: z.ZodOptional<z.ZodString>;
    variant: z.ZodOptional<z.ZodString>;
    model: z.ZodOptional<z.ZodString>;
    tools: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    candidates: z.ZodOptional<z.ZodNumber>;
    config: z.ZodOptional<z.ZodObject<{
        version: z.ZodOptional<z.ZodString>;
        temperature: z.ZodOptional<z.ZodNumber>;
        maxOutputTokens: z.ZodOptional<z.ZodNumber>;
        topK: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        version: z.ZodOptional<z.ZodString>;
        temperature: z.ZodOptional<z.ZodNumber>;
        maxOutputTokens: z.ZodOptional<z.ZodNumber>;
        topK: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        version: z.ZodOptional<z.ZodString>;
        temperature: z.ZodOptional<z.ZodNumber>;
        maxOutputTokens: z.ZodOptional<z.ZodNumber>;
        topK: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, z.ZodTypeAny, "passthrough">>>;
    input: z.ZodOptional<z.ZodObject<{
        schema: z.ZodUnknown;
        default: z.ZodAny;
    }, "strip", z.ZodTypeAny, {
        schema?: unknown;
        default?: any;
    }, {
        schema?: unknown;
        default?: any;
    }>>;
    output: z.ZodOptional<z.ZodObject<{
        format: z.ZodOptional<z.ZodEnum<["json", "text", "media"]>>;
        schema: z.ZodOptional<z.ZodUnknown>;
    }, "strip", z.ZodTypeAny, {
        format?: "json" | "text" | "media" | undefined;
        schema?: unknown;
    }, {
        format?: "json" | "text" | "media" | undefined;
        schema?: unknown;
    }>>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
}, "strip", z.ZodTypeAny, {
    name?: string | undefined;
    variant?: string | undefined;
    model?: string | undefined;
    tools?: string[] | undefined;
    candidates?: number | undefined;
    config?: z.objectOutputType<{
        version: z.ZodOptional<z.ZodString>;
        temperature: z.ZodOptional<z.ZodNumber>;
        maxOutputTokens: z.ZodOptional<z.ZodNumber>;
        topK: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, z.ZodTypeAny, "passthrough"> | undefined;
    input?: {
        schema?: unknown;
        default?: any;
    } | undefined;
    output?: {
        format?: "json" | "text" | "media" | undefined;
        schema?: unknown;
    } | undefined;
    metadata?: Record<string, unknown> | undefined;
}, {
    name?: string | undefined;
    variant?: string | undefined;
    model?: string | undefined;
    tools?: string[] | undefined;
    candidates?: number | undefined;
    config?: z.objectInputType<{
        version: z.ZodOptional<z.ZodString>;
        temperature: z.ZodOptional<z.ZodNumber>;
        maxOutputTokens: z.ZodOptional<z.ZodNumber>;
        topK: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, z.ZodTypeAny, "passthrough"> | undefined;
    input?: {
        schema?: unknown;
        default?: any;
    } | undefined;
    output?: {
        format?: "json" | "text" | "media" | undefined;
        schema?: unknown;
    } | undefined;
    metadata?: Record<string, unknown> | undefined;
}>;
type PromptFrontmatter = z.infer<typeof PromptFrontmatterSchema>;
declare function toMetadata(attributes: unknown): Partial<PromptMetadata>;
declare function toFrontmatter(md: PromptMetadata): PromptFrontmatter;

export { type PromptFrontmatter, PromptFrontmatterSchema, type PromptMetadata, toFrontmatter, toMetadata };
